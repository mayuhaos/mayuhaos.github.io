# 根据用户理解重新设计表结构

## 1. 用户理解的默认配置

用户理解的**默认配置**是：
> 查询所有我在model_check_portrait_field表中配置的所有参数

即：

- 默认情况下，系统会查询`model_check_portrait_field`表中所有配置的参数
- 不需要额外的默认配置标识
- 每个省份可以在此基础上进行个性化配置

## 2. 表结构设计

### 2.1 基础字段配置表（model_check_portrait_field）

**用途**：存储所有字段的基础配置，包括字段编码、默认名称、类型等

| 字段名         | 数据类型         | 约束                                                             | 描述                          |
|-------------|--------------|----------------------------------------------------------------|-----------------------------|
| id          | BIGINT       | PRIMARY KEY, AUTO_INCREMENT                                    | 主键ID                        |
| field_code  | VARCHAR(50)  | NOT NULL UNIQUE                                                | 字段编码（对应返回的字段名，如totalCalls）  |
| field_name  | VARCHAR(100) | NOT NULL                                                       | 字段中文名称                      |
| field_type  | TINYINT      | NOT NULL                                                       | 字段类型（1：integer，2：浮点数，3：字符串） |
| unit        | VARCHAR(20)  | NULL                                                           | 单位信息（如：次、秒、%等）              |
| create_time | DATETIME     | NOT NULL DEFAULT CURRENT_TIMESTAMP                             | 创建时间                        |
| update_time | DATETIME     | NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间                        |

### 2.2 省份字段配置表（model_check_province_field_config）

**用途**：存储省份对字段的个性化配置，包括展示区域、排序、别名、单位等

| 字段名           | 数据类型                                      | 约束                                                             | 描述                         |
|---------------|-------------------------------------------|----------------------------------------------------------------|----------------------------|
| id            | BIGINT                                    | PRIMARY KEY, AUTO_INCREMENT                                    | 主键ID                       |
| province_code | VARCHAR(20)                               | NOT NULL                                                       | 省份编码（不能为空，每个省份的配置都是独立的）    |
| field_code    | VARCHAR(50)                               | NOT NULL                                                       | 字段编码                       |
| display_type  | TINYINT                                   | NOT NULL                                                       | 展示区域类型（1：上方展示，2：雷达图）       |
| field_alias   | VARCHAR(100)                              | NULL                                                           | 字段别名（为空则使用基础配置的field_name） |
| unit          | VARCHAR(20)                               | NULL                                                           | 单位信息（为空则使用基础配置的unit）       |
| sort_order    | INT                                       | NOT NULL DEFAULT 0                                             | 排序顺序                       |
| is_enabled    | TINYINT                                   | NOT NULL DEFAULT 1                                             | 是否启用（1-启用，0-禁用）            |
| create_time   | DATETIME                                  | NOT NULL DEFAULT CURRENT_TIMESTAMP                             | 创建时间                       |
| update_time   | DATETIME                                  | NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间                       |
| UNIQUE KEY    | (province_code, field_code, display_type) |                                                                | 确保每个省份每个字段在每个展示区域只有一条配置    |

## 3. 配置查询逻辑

### 3.1 查询流程

1. **查询基础字段配置**：查询`model_check_portrait_field`表中所有配置的字段
2. **查询省份字段配置**：根据省份编码查询`model_check_province_field_config`表中该省份的配置
3. **合并配置**：
    - 如果省份有配置，则使用省份配置中的`display_type`、`field_alias`、`unit`、`sort_order`、`is_enabled`
    - 如果省份没有配置，则使用基础配置中的`field_name`、`unit`，并默认`display_type`为1（上方展示），`sort_order`为0，
      `is_enabled`为1
4. **过滤配置**：只保留`is_enabled`为1的配置
5. **排序配置**：根据`sort_order`字段排序
6. **生成返回结果**：根据合并后的配置，生成headList和radarChart

### 3.2 示例

#### 示例1：省份有配置

- 基础字段配置：totalCalls（总话务量，单位：次）
- 省份配置：BJ（北京），totalCalls，display_type=1，field_alias=北京总话务量，unit=通，sort_order=1，is_enabled=1
- 合并后：totalCalls，name=北京总话务量，unit=通，display_type=1，sort_order=1，is_enabled=1

#### 示例2：省份没有配置

- 基础字段配置：totalCalls（总话务量，单位：次）
- 省份配置：SH（上海），没有totalCalls的配置
- 合并后：totalCalls，name=总话务量，unit=次，display_type=1，sort_order=0，is_enabled=1

## 4. 接口修改方案

### 4.1 步骤一：创建实体类和Mapper

- 创建 `ModelCheckPortraitField` 实体类
- 创建 `ModelCheckProvinceFieldConfig` 实体类
- 创建 `ModelCheckPortraitFieldMapper` 接口
- 创建 `ModelCheckProvinceFieldConfigMapper` 接口

### 4.2 步骤二：修改接口实现

1. **查询基础字段配置**：
   ```java
   List<ModelCheckPortraitField> baseFields = portraitFieldMapper.selectList(null);
   ```

2. **查询省份字段配置**：
   ```java
   List<ModelCheckProvinceFieldConfig> provinceConfigs = provinceFieldConfigMapper.selectList(
       new QueryWrapper<ModelCheckProvinceFieldConfig>()
           .eq("province_code", provinceCode)
   );
   ```

3. **将省份字段配置转换为Map**：
   ```java
   Map<String, ModelCheckProvinceFieldConfig> provinceConfigMap = provinceConfigs.stream()
       .collect(Collectors.toMap(ModelCheckProvinceFieldConfig::getFieldCode, Function.identity()));
   ```

4. **合并配置**：
   ```java
   List<Map<String, Object>> mergedConfigs = new ArrayList<>();
   for (ModelCheckPortraitField baseField : baseFields) {
       String fieldCode = baseField.getFieldCode();
       ModelCheckProvinceFieldConfig provinceConfig = provinceConfigMap.get(fieldCode);
       
       Map<String, Object> mergedConfig = new HashMap<>();
       mergedConfig.put("fieldCode", fieldCode);
       
       // 字段名称：如果省份有配置别名则使用别名，否则使用基础配置的名称
       mergedConfig.put("fieldName", provinceConfig != null && provinceConfig.getFieldAlias() != null 
           ? provinceConfig.getFieldAlias() 
           : baseField.getFieldName());
       
       // 单位：如果省份有配置单位则使用该单位，否则使用基础配置的单位
       mergedConfig.put("unit", provinceConfig != null && provinceConfig.getUnit() != null 
           ? provinceConfig.getUnit() 
           : baseField.getUnit());
       
       // 字段类型：使用基础配置的字段类型
       mergedConfig.put("fieldType", baseField.getFieldType());
       
       // 展示区域：如果省份有配置则使用该配置，否则默认为1（上方展示）
       mergedConfig.put("displayType", provinceConfig != null 
           ? provinceConfig.getDisplayType() 
           : 1);
       
       // 排序顺序：如果省份有配置则使用该配置，否则默认为0
       mergedConfig.put("sortOrder", provinceConfig != null 
           ? provinceConfig.getSortOrder() 
           : 0);
       
       // 是否启用：如果省份有配置则使用该配置，否则默认为1（启用）
       mergedConfig.put("isEnabled", provinceConfig != null 
           ? provinceConfig.getIsEnabled() 
           : 1);
       
       mergedConfigs.add(mergedConfig);
   }
   ```

5. **过滤和排序**：
   ```java
   // 过滤启用的配置
   List<Map<String, Object>> enabledConfigs = mergedConfigs.stream()
       .filter(config -> (Integer) config.get("isEnabled") == 1)
       .collect(Collectors.toList());
   
   // 按排序顺序排序
   enabledConfigs.sort(Comparator.comparing(config -> (Integer) config.get("sortOrder")));
   ```

6. **生成返回结果**：
   ```java
   // 按展示区域分组
   Map<Integer, List<Map<String, Object>>> configsByDisplayType = enabledConfigs.stream()
       .collect(Collectors.groupingBy(config -> (Integer) config.get("displayType")));
   
   // 提取字段值
   List<Map<String, Object>> headList = new ArrayList<>();
   List<Map<String, Object>> radarChart = new ArrayList<>();
   
   // 处理headList（display_type=1）
   List<Map<String, Object>> headConfigs = configsByDisplayType.getOrDefault(1, Collections.emptyList());
   for (Map<String, Object> config : headConfigs) {
       String fieldCode = (String) config.get("fieldCode");
       Map<String, Object> fieldData = new HashMap<>();
       fieldData.put("name", config.get("fieldName"));
       fieldData.put("code", fieldCode);
       fieldData.put("currentValue", BeanUtils.getProperty(originalNowRes, fieldCode));
       fieldData.put("averageValue", BeanUtils.getProperty(originalAvgRes, fieldCode));
       fieldData.put("periodValue", BeanUtils.getProperty(originalLastRes, fieldCode));
       fieldData.put("unit", config.get("unit"));
       headList.add(fieldData);
   }
   
   // 处理radarChart（display_type=2）
   List<Map<String, Object>> radarConfigs = configsByDisplayType.getOrDefault(2, Collections.emptyList());
   for (Map<String, Object> config : radarConfigs) {
       String fieldCode = (String) config.get("fieldCode");
       Map<String, Object> fieldData = new HashMap<>();
       fieldData.put("name", config.get("fieldName"));
       fieldData.put("code", fieldCode);
       fieldData.put("currentValue", BeanUtils.getProperty(originalNowRes, fieldCode));
       fieldData.put("averageValue", BeanUtils.getProperty(originalAvgRes, fieldCode));
       fieldData.put("periodValue", BeanUtils.getProperty(originalLastRes, fieldCode));
       fieldData.put("unit", config.get("unit"));
       radarChart.add(fieldData);
   }
   ```

## 5. 优势

### 5.1 符合用户理解

- 默认配置是查询所有在`model_check_portrait_field`表中配置的所有参数
- 不需要额外的默认配置标识
- 每个省份可以在此基础上进行个性化配置

### 5.2 避免冗余配置

- 基础字段配置只需要配置一次
- 省份只需要配置差异化的部分
- 不需要为每个省份都配置所有字段

### 5.3 支持灵活配置

- 支持字段的展示区域配置
- 支持字段的排序配置
- 支持字段的别名配置
- 支持字段的单位配置
- 支持字段的启用/禁用配置

### 5.4 易于扩展

- 新增字段时，只需在基础字段配置表中添加记录
- 新增省份时，自动使用基础配置，不需要立即配置
- 支持动态添加新的字段，无需重启服务

## 6. 后续优化

1. **缓存配置**：将配置缓存到Redis中，提高查询效率
2. **字段分组**：支持字段分组，便于前端展示时进行分类
3. **字段权限**：支持根据用户角色配置可查看的字段
4. **数据格式化**：支持配置字段的格式化规则，如保留小数位数、百分比显示等

通过以上设计，符合用户对默认配置的理解，同时支持省份的个性化配置，避免了冗余配置，提高了配置管理的效率。