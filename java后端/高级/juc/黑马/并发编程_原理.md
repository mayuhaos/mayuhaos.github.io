# 原理篇

# 指令级并行原理

# 1.名词

# Clock Cycle Time

主频的概念大家接触的比较多，而CPU的Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是CPU能够识别的最小时间单位，比如说4G主频的CPU的Clock
Cycle Time就是0.25ns，作为对比，我们墙上挂钟的Cycle Time是1s

例如，运行一条加法指令一般需要一个时钟周期时间

# CPI

有的指令需要更多的时钟周期时间，所以引出了CPI（Cycles Per Instruction）指令平均时钟周期数

# IPC

IPC（Instruction Per Clock Cycle）即CPI的倒数，表示每个时钟周期能够运行的指令数

# CPU执行时间

程序的 CPU 执行时间，即我们前面提到的 user + system 时间，可以用下面的公式来表示

程序 CPU 执行时间 = 指令数 * CPI * Clock Cycle Time

# 2.鱼罐头的故事

加工一条鱼需要50分钟，只能一条鱼、一条鱼顺序加工...

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751454.jpg)

可以将每个鱼罐头的加工流程细分为5个步骤：

- 去鳞清洗10分钟
- 蒸煮沥水 10 分钟
- 加注汤料 10分钟
- 杀菌出锅10分钟  
  真空封罐10分钟

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751455.jpg)

<table><tr><td>第一条</td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td><td>真空封罐</td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td><td>真空封罐</td></tr><tr><td>第二条</td><td></td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td><td>真空封罐</td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td></tr><tr><td>第三条</td><td></td><td></td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td><td>真空封罐</td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td></tr><tr><td>第四条</td><td></td><td></td><td></td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td><td>真空封罐</td><td>去鳞清洗</td><td>蒸煮沥水</td></tr><tr><td>第五条</td><td></td><td></td><td></td><td></td><td>去鳞清洗</td><td>蒸煮沥水</td><td>加注汤料</td><td>杀菌出锅</td><td>真空封罐</td><td>去鳞清洗</td></tr></table>

即使只有一个工人，最理想的情况是：他能够在10分钟内同时做好这5件事，因为对第一条鱼的真空装罐，不会影响对第二条鱼的杀菌出锅...

# 3. 指令重排序优化

事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的CPU指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为：取指令-指令译码-执行指令-内存访问-数据写回这5个阶段

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751456.jpg)

# 术语参考：

- instruction fetch (IF)
- instruction decode (ID)
- execute (EX)  
  memory access (MEM)  
  register write back (WB)

在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，这一技术在 80's 中叶到 90's
中叶占据了计算架构的重要地位。

# 提示：

分阶段，分工是提升效率的关键！

指令重排的前提是，重排指令不能影响结果，例如

# // 可以重排的例子

int a = 10; // 指令1

int b = 20; // 指令2

System.out.println(a + b);

# // 不能重排的例子

int a = 10; // 指令1

int b = a - 5; // 指令2

参考：Scoreboarding and the Tomasulo algorithm (which is similar to scoreboarding but makes use of register renaming) are
two of the most common techniques for implementing out-of-order execution and instruction-level parallelism.

# 4. 支持流水线的处理器

现代CPU支持多级指令流水线，例如支持同时执行取指令－指令译码－执行指令－内存访问－数据写回的处理器，就可以称之为五级指令流水线。这时CPU可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一条执行时间最长的复杂指令）， $\mathrm{IPC} = 1$
，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。

提示：

奔腾四（Pentium 4）支持高达35级流水线，但由于功耗太高被废弃

<table><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td><td></td><td></td></tr><tr><td>i</td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td><td></td></tr><tr><td>t</td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td></tr></table>

# 5. SuperScalar 处理器

大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单元等，这样可以把多条指令也可以做到并行获取、译码等，CPU
可以在一个时钟周期内，执行多于一条指令，IPC  $>1$

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751457.jpg)

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751458.jpg)

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751459.jpg)

<table><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td rowspan="2">i</td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td rowspan="2">t</td><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td rowspan="2">IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td rowspan="2">IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr><tr><td rowspan="2">IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td><td></td></tr><tr><td>IF</td><td>ID</td><td>EX</td><td>MEM</td><td>WB</td><td></td></tr></table>

# CPU 缓存结构原理

# 1. CPU 缓存结构

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751460.jpg)

内存

# 查看 cpu 缓存

root@yihang01 ~ lscpu

Architecture: x86_64

CPU op-mode(s): 32-bit, 64-bit

Byte Order: Little Endian

CPU(s): 1

On-line CPU(s) list: 0

Thread(s) per core: 1

Core(s) per socket: 1

Socket(s): 1

NUMA node(s): 1

Vendor ID: GenuineIntel

CPU family: 6

Model: 142

Model name: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz

Stepping: 11

CPU MHz: 1992.002

BogoMIPS: 3984.00

Hypervisor vendor: VMware

Virtualization type: full

L1d cache: 32K

L1i cache: 32K

L2 cache: 256K

L3 cache: 8192K

NUMA node0 CPU(s): 0

速度比较

<table><tr><td>从 cpu 到</td><td>大约需要的时钟周期</td></tr><tr><td>寄存器</td><td>1 cycle</td></tr><tr><td>L1</td><td>3~4 cycle</td></tr><tr><td>L2</td><td>10~20 cycle</td></tr><tr><td>L3</td><td>40~45 cycle</td></tr><tr><td>内存</td><td>120~240 cycle</td></tr></table>

查看 cpu 缓存行

```txt
root@yihang01 ~ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size 64
```

cpu拿到的内存地址格式是这样的

[高位组标记][低位索引][偏移量]

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751461.jpg)

# 2. CPU 缓存读

读取数据流程如下

- 根据低位，计算在缓存中的索引
- 判断是否有效

○ 0 去内存读取新数据更新缓存行  
○ 1 再对比高位组标记是否一致

一致，根据偏移量返回缓存数据  
不一致，去内存读取新数据更新缓存行

# 3. CPU 缓存一致性

# MESI协议

1. E、S、M 状态的缓存行都可以满足 CPU 的读请求
2. E 状态的缓存行，有写请求，会将状态改为 M，这时并不触发向主存的写
3. E 状态的缓存行，必须监听该缓存行的读操作，如果有，要变为 S 状态

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751462.jpg)

4. M 状态的缓存行，必须监听该缓存行的读操作，如果有，先将其它缓存（S 状态）中该缓存行变成 I 状态（即 6. 的流程），写入主存，自己变为
   S 状态
5. S 状态的缓存行，有写请求，走 4. 的流程
6. S 状态的缓存行，必须监听该缓存行的失效操作，如果有，自己变为 I 状态  
   7.1 状态的缓存行，有读请求，必须从主存读取

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751463.jpg)

# 4.内存屏障

Memory Barrier ( Memory Fence )

# - 可见性

○ 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中  
。而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据

# - 有序性

○ 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后  
o 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751464.jpg)

# volatile 原理

volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）

- 对 volatile 变量的写指令后会加入写屏障
- 对 volatile 变量的读指令前会加入读屏障

# 1. 如何保证可见性

- 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中

```txt
public void actor2(I(Result r) { num  $= 2$  ready  $\equiv$  true; // ready是volatile赋值带写屏障 //写屏障
```

- 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据

```txt
public void actor1(I(Result r) { //读屏障 // ready是volatile读取值带读屏障 if(ready){ r.r1 = num + num; }else{ r.r1 = 1; }
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751465.jpg)

# 2. 如何保证有序性

- 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后

```txt
public void actor2(I(Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障
```

- 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

```txt
public void actor1(I(Result r) { //读屏障 // ready是volatile读取值带读屏障 if(ready){ r.r1 = num + num; }else{ r.r1 = 1; }
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751466.jpg)

还是那句话，不能解决指令交错：

- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去
- 而有序性的保证也只是保证了本线程内相关代码不被重排序

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751467.jpg)

# 3. double-checked locking 问题

以著名的 double-checked locking 单例模式为例

```java
public final class Singleton {
    private Singleton() {}
    private static SingletonINSTANCE = null;
    public static Singleton.getInstance()
        if (INSTANCE == null) { // t2
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                if (INSTANCE == null) { // t1
                   INSTANCE = new Singleton();
            }
        }
    }
    returnINSTANCE;
}
```

以上的实现特点是：

- 懒惰实例化
- 首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁
- 有隐含的，但很关键的一点：第一个 if 使用了INSTANCE 变量，是在同步块之外

但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：

```txt
0: getstatic #2 //FieldINSTANCE:Lcn/itcast/n5/Singleton;   
3: ifnonnull 37   
6: ldc #3 //class cn/itcast/n5/Singleton   
8: dup   
9: astore_0   
10: monitorter   
11: getstatic #2 //FieldINSTANCE:Lcn/itcast/n5/Singleton;   
14: ifnonnull 27   
17: new #3 //class cn/itcast/n5/Singleton   
20: dup   
21: invokespecial #4 //Method "<init>":()V   
24: putstatic #2 //FieldINSTANCE:Lcn/itcast/n5/Singleton;   
27: aload_0   
28: monitorexit   
29: goto 37   
32: astore_1   
33: aload_0   
34: monitorexit   
35: aload_1   
36: athrow   
37: getstatic #2 //FieldINSTANCE:Lcn/itcast/n5/Singleton;   
40: areturn
```

# 其中

- 17 表示创建对象，将对象引用入栈 // new Singleton
- 20表示复制一份对象引用 // 引用地址
- 21 表示利用一个对象引用，调用构造方法
- 24 表示利用一个对象引用，赋值给 staticINSTANCE

也许jvm会优化为：先执行24，再执行21。如果两个线程t1，t2按如下时间序列执行：

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751468.jpg)

关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取INSTANCE 变量的值

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例

对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意在JDK5以上的版本的volatile才会真正有效

# 4. double-checked locking 解决

```java
public final class Singleton {
    private Singleton() {}
    private static volatile SingletonINSTANCE = null;
    public static Singleton.getInstance()
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) { // t2
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) { // t1
                   INSTANCE = new Singleton();
                }
            }
        }
    returnINSTANCE;
}
```

字节码上看不出来 volatile 指令的效果

```txt
//  
//  
加入对INSTANCE变量的读屏障  
0: getstatic #2 //FieldINSTANCE:Lcn/itcast/n5/Singleton;
```

```txt
3: ifnonnull 37  
6: ldc #3 // class cn/itcast/n5/Singleton  
8: dup  
9: astore_0  
10: monitorenter保证原子性、可见性  
11: getstatic #2 // FieldINSTANCE:Lcn/itcast/n5/Singleton;  
14: ifnonnull 27  
17: new #3 // class cn/itcast/n5/Singleton  
20: dup  
21: invokespecial #4 // Method "<init>":()V  
24: putstatic #2 // FieldINSTANCE:Lcn/itcast/n5/Singleton;  
// 加入对INSTANCE变量的写屏障  
27: aload_0  
28: monitorexit 保证原子性、可见性  
29: goto 37  
32: astore_1  
33: aload_0  
34: monitorexit  
35: aload_1  
36: athrow  
37: getstatic #2 // FieldINSTANCE:Lcn/itcast/n5/Singleton;  
40: areturn
```

如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：

- 可见性

o 写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中  
。而读屏障（Ifence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据

- 有序性

。写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后  
。读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

- 更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751469.jpg)

# final 原理

# 1. 设置 final 变量的原理

理解了volatile原理，再对比final的实现就比较简单了

```txt
public class TestFinal { final int a = 20; }
```

# 字节码

```txt
0: aload_0  
1: invokespecial #1 // Method java/lang/Object."<init>":()V  
4: aload_0  
5: bipush 20  
7: putfield #2 // Field a:I  
    -- 写屏障  
10: return
```

发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为
0 的情况

# 2. 获取 final 变量的原理

# Monitor 原理

# Monitor 被翻译为监视器或管程

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向
Monitor 对象的指针

# Monitor结构如下

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751470.jpg)

- 刚开始 Monitor 中 Owner 为 null
- 当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor 中只能有一个 Owner
- 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED
- Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的
- 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析

# 注意：

- synchronized 必须是进入同一个对象的 monitor 才有上述的效果
- 不加 synchronized 的对象不会关联监视器，不遵从以上规则

# synchronized 原理

```txt
static final Object lock  $=$  new Object();   
static int counter  $= 0$    
public static void main(String[] args){ synchronized (lock){ counter++; }   
}
```

# 对应的字节码为

```typescript
public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String);V flags: ACC_PUBLIC, ACC_STATIC
```

Code:

```txt
stack=2, locals=3, args_size=1  
0: getstatic #2 //<-lock引用（synchronized开始）  
3: dup  
4: astore_1 // lock引用 -> slot 1  
5: monitorenter //将lock对象MarkWord置为Monitor指针  
6: getstatic #3 //<-i  
9: iconst_1 //准备常数1  
10: iadd //+1  
11: putstatic #3 //->i  
14: aload_1 //<-lock引用  
15: monitorexit //将lock对象MarkWord重置，唤醒EntryList  
16: goto 24  
19: astore_2 //e->slot 2  
20: aload_1 //<-lock引用  
21: monitorexit //将lock对象MarkWord重置，唤醒EntryList  
22: aload_2 //<-slot 2(e)  
23: atthrow //throw e  
24: return  
Exception table:  
from to target type  
6 16 19 any  
19 22 19 any  
LineNumberTable:  
line8:0  
line9:6  
line10:14  
line11:24  
LocalVariableTable:  
Start Length Slot Name Signature  
0 25 0 args [Ljava/lang/String;]  
StackMapTable: number_of_entries = 2  
frame_type = 255 /* full_frame */  
offset delta = 19  
locals = [class"[Ljava/lang/String", class java/lang/Object]  
stack = [class java/lang/Throwable]  
frame_type = 250 /* chop */  
offset delta = 4
```

注意

方法级别的 synchronized 不会在字节码指令中有所体现

# synchronized 原理进阶

# 1. 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。

轻量级锁对使用者是透明的，即语法仍然是 synchronized

假设有两个方法同步块，利用同一个对象加锁

```java
static final Object obj = new Object();  
public static void method1() {  
    synchronized(obj) {  
        // 同步块 A  
        method2();  
    }  
}  
public static void method2() {  
    synchronized(obj) {  
        // 同步块 B  
    }  
}
```

- 创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751471.jpg)

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751472.jpg)

- 让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751473.jpg)

- 如果cas替换成功，对象头中存储了锁记录地址和状态00，表示由该线程给对象加锁，这时图示如下

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751474.jpg)

如果cas失败，有两种情况

。如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程  
。如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751475.jpg)

- 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751476.jpg)

- 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头

○ 成功，则解锁成功  
。失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

# 2. 锁膨胀

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```swift
static Object obj = new Object();  
public static void method1() {  
    synchronized (obj) {  
        // 同步块  
    }  
}
```

- 当 Thread-1 进行轻量级加锁时, Thread-0 已经对该对象加了轻量级锁

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751477.jpg)

- 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程

○ 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址  
然后自己进入 Monitor 的 EntryList BLOCKED

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751479.jpg)

- 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到
  Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程

# 3. 自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

自旋重试成功的情况

<table><tr><td>线程1 (core 1上)</td><td>对象Mark</td><td>线程2 (core 2上)</td></tr><tr><td>-</td><td>10 (重量锁)</td><td>-</td></tr><tr><td>访问同步块,获取monitor</td><td>10 (重量锁)重量锁指针</td><td>-</td></tr><tr><td>成功(加锁)</td><td>10 (重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10 (重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10 (重量锁)重量锁指针</td><td>访问同步块,获取monitor</td></tr><tr><td>执行同步块</td><td>10 (重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10 (重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>成功(解锁)</td><td>01 (无锁)</td><td>自旋重试</td></tr><tr><td>-</td><td>10 (重量锁)重量锁指针</td><td>成功(加锁)</td></tr><tr><td>-</td><td>10 (重量锁)重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>...</td><td>...</td></tr></table>

# 自旋重试失败的情况

<table><tr><td>线程1 (core 1上)</td><td>对象Mark</td><td>线程2 (core 2上)</td></tr><tr><td>-</td><td>10(重量锁)</td><td>-</td></tr><tr><td>访问同步块,获取monitor</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>成功(加锁)</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>访问同步块,获取monitor</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>...</td><td>...</td></tr></table>

- 自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势。
- 在Java 6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。
- Java 7 之后不能控制是否开启自旋功能

# 4. 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID
是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有

例如：

```java
static final Object obj = new Object();  
public static void m1() {  
    synchronized(obj) {  
        // 同步块 A  
        m2();  
    }  
}  
public static void m2() {  
    synchronized(obj) {  
        // 同步块 B  
        m3();  
    }  
}  
public static void m3() {  
    synchronized(obj) {
```

// 同步块 C

}

轻量级锁

m1内调用synchronized(obj)

用锁记录 替换 markword

生成锁记录

m2内调用synchronized(obj)

用锁记录替换markword——对象

生成锁记录

m2内调用synchronized(obj)

- 用 锁记录 替换 markword

生成锁记录

偏向锁

m1内调用synchronized(obj)

- 用 ThreadID 替换 markword

m2内调用synchronized(obj)

检查 ThreadID 是否是自己——对象

m2内调用synchronized(obj)

检查 ThreadID 是否是自己

# 回忆一下对象头格式

<table><tr><td colspan="5">Mark Word (64 bits)</td><td>State</td></tr><tr><td>unused:25</td><td>hashcode:31</td><td>unused:1</td><td>age:4</td><td>biased_lock:0</td><td>01</td></tr><tr><td>thread:54</td><td>epoch:2</td><td>unused:1</td><td>age:4</td><td>biased_lock:1</td><td>01</td></tr><tr><td colspan="4">ptr_to_lock_record:62</td><td>00</td><td>Lightweight Locked</td></tr><tr><td colspan="4">ptr_to_heavyweight_monitor:62</td><td>10</td><td>Heavyweight Locked</td></tr><tr><td colspan="4"></td><td>11</td><td>Marked for GC</td></tr></table>

# 一个对象创建时：

- 如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0
- 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟
- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到
  hashcode 时才会赋值

# 1）测试延迟特性

# 2）测试偏向锁

```txt
class Dog {}
```

利用 jol 第三方工具来查看对象头信息（注意这里我扩展了 jol 让它输出更为简洁）

```java
//添加虚拟机参数-XX:BiasedLockingStartupDelay  $= 0$    
public static void main(String[] args) throws IOException{ Dogd  $\equiv$  new Dog(); ClassLayout classLayout  $\equiv$  ClassLayout.parseInstance(d);   
new Thread() -> { log.debug("synchronized前"); System.out.println(classLayout.toPrintableSimple(true)); synchronized（d）{ log.debug("synchronized中"); System.out.println(classLayout.toPrintableSimple(true)); } log.debug("synchronized后"); System.out.println(classLayout.toPrintableSimple(true)); }, "t1").start();
```

}

# 输出

```txt
11:08:58.117 c.TestBiased [t1] - synchronized 前  
00000000 00000000 00000000 00000000 00000000 00000000 00000101  
11:08:58.121 c.TestBiased [t1] - synchronized 中  
00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101  
11:08:58.121 c.TestBiased [t1] - synchronized 后  
00000000 00000000 00000000 00000000 0011111 11101011 11010000 000001
```

# 注意

处于偏向锁的对象解锁后，线程id仍存储于对象头中

# 3）测试禁用

在上面测试代码运行时在添加 VM 参数 -XX:-UseBiasedLocking 禁用偏向锁

# 输出

```txt
11:13:10.018 c.TestBiased [t1] - synchronized 前  
00000000 00000000 00000000 00000000 00000000 00000000 00000001  
11:13:10.021 c.TestBiased [t1] - synchronized 中  
00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000  
11:13:10.021 c.TestBiased [t1] - synchronized 后  
00000000 00000000 00000000 00000000 00000000 00000000 000
```

# 4) 测试 hashCode

- 正常状态对象一开始是没有 hashCode 的，第一次调用才生成

# 撤销-调用对象hashCode

调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销

- 轻量级锁会在锁记录中记录 hashCode
- 重量级锁会在 Monitor 中记录 hashCode

在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking

# 输出

```txt
11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015  
11:22:10.391 c.TestBiased [t1] - synchronized 前  
00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001  
11:22:10.393 c.TestBiased [t1] - synchronized 中  
00000000 00000000 00000000 00000000 00100000 11000111 11110011 01101000  
11:22:10.393 c.TestBiased [t1] - synchronized 后  
00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001
```

# 撤销-其它线程使用对象

当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁

```txt
private static void test2() throws InterruptedException{ Dog d = new Dog(); Thread t1 = new Thread(）->{ synchronized (d){ log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } synchronized(TestBiased.class){ TestBiased.class.notify(); } //如果不用wait/notification使用join必须打开下面的注释 //因为：t1线程不能结束，否则底层线程可能被jvm重用作为t2线程，底层线程id是一样的 /*try{ System.in.read(); }catch（IOException e）{ e.printStackTrace(); }*/ }, "t1"); t1.start(); Thread t2  $=$  new Thread(）->{ synchronized (TestBiased.class){ try{ TestBiased.class.wait(); } catch（InterruptedException e）{ e.printStackTrace(); } } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d){ log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(ClassLayoutparseInstance(d).toPrintableSimple(true)); }, "t2"); t2.start();
```

# 输出

```txt
[t1] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101  
[t2] - 00000000 00000000 00000000 00000000 00011111 01000001 00010000 00000101  
[t2] - 00000000 00000000 08888888 66666666 66666666 66666666 66666666 66666666 66666666 66666666 66666666 66666666 66666666 66
```

撤销 - 调用 wait/send

```java
public static void main(String[] args) throws遇到了Exception { Dog d = new Dog(); Thread t1 = new Thread() -> { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d) { log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); try { d.wait(); } catch (遇到了Exception e) { e.printStackTrace(); } log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true)); } }, "t1"); t1.start();   
new Thread() -> { try { Thread.sleep(6000); } catch (遇到了Exception e) { e.printStackTrace(); } synchronized (d) { log.debug("notify"); d.notify(); } }, "t2").start();
```

# 输出

```txt
[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000101  
[t1] - 00000000 00000000 00000000 00000000 0011111 10110011 11111000 0000101  
[t2] - notify  
[t1] - 00000000 00000000 00000000 00000000 00111100 11010111 11111111 11111111
```

# 批量重偏向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的Thread ID

当撤销偏向锁阈值超过20次后，jvm会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程

```java
private static void test3() throws遇到了 unexpected exception {
    Vector<Dog> list = new Vector<Dog>(); 
    Thread t1 = new Thread(); 
    for (int i = 0; i < 30; i++) { 
        Dog d = new Dog(); 
        list.add(d); 
        synchronized (d) { 
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); 
        } 
    } 
    synchronized (list) { 
        list.notify(); 
    }, "t1"); 
    t1.start(); 
    Thread t2 = new Thread(); -> { 
        synchronized (list) { 
            try { 
                list.wait(); 
            } catch (InterruptedException e) { 
                e.printStackTrace(); 
            } 
        } 
    } 
    log.debug(""); 
    for (int i = 0; i < 30; i++) { 
        Dog d = list.get(i); 
        log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); 
        synchronized (d) { 
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); 
        } 
        log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); 
    }, "t2"); 
    t2.start();
```

输出

[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - ===============

[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001

[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001

[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000001

[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000001

[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000001

[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000001

[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000

[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000001

[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101

<table><tr><td>[t2] - 7</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 7</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000001</td></tr><tr><td>[t2] - 8</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00011111</td><td>11110011</td><td>11100000</td><td>00000101</td></tr><tr><td>[t2] - 8</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 8</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>0000001</td></tr><tr><td>[t2] - 9</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00011111</td><td>11110011</td><td>11100000</td><td>00000101</td></tr><tr><td>[t2] - 9</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 9</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>0000001</td></tr><tr><td>[t2] - 10</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00011111</td><td>11110011</td><td>11100000</td><td>00000101</td></tr><tr><td>[t2] - 10</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 10</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>0000001</td></tr><tr><td>[t2] - 11</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 11</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 12</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>11110011</td><td>11100000</td><td>00000101</td></tr><tr><td>[t2] - 12</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000000</td></tr><tr><td>[t2] - 12</td><td>00000000</td><td>0000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>000001</td></tr><tr><td>[t2] - 13</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>11110011</td><td>11100000</td><td>0000101</td></tr><tr><td>[t2] - 13</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>0000000</td></tr><tr><td>[t2] - 14</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>11110011</td><td>11100000</td><td>00001</td></tr><tr><td>[t2] - 14</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>11110111</td><td>00000</td></tr><tr><td>[t2] - 15</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>11110011</td><td>111000</td><td></td></tr><tr><td>[t2] - 15</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00100000</td><td>01011000</td><td>1111</td><td></td></tr><tr><td>[t2] - 16</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>1111</td><td></td><td></td></tr><tr><td>[t2] - 16</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>1111</td><td></td><td></td></tr><tr><td>[t2] - 17</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00111111</td><td>1111</td><td></td><td></td></tr><tr><td>[t2] - 17</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00211111</td><td>1111</td><td></td><td></td></tr><tr><td>[t2] - 18</td><td>00000000</td><td>00000000</td><td>00000000</td><td>00211111</td><td>1111</td><td></td><td></td><td></td></tr><tr><td>[t2] - 18</td><td>00000000</td><td>00000000</td><td>00211111</td><td>1111</td><td>1111</td><td></td><td></td><td></td></tr><tr><td>[t2] - 19</td><td>00000000</td><td>00211111</td><td>1111</td><td>1111</td><td>1111</td><td></td><td></td><td></td></tr><tr><td>[t2] - 19</td><td>00000000</td><td>02111111</td><td>1111</td><td>1111</td><td>1111</td><td></td><td></td><td></td></tr><tr><td>[t2] - 21</td><td>02111111</td><td>1111</td><td>1111</td><td>1111</td><td>1111</td><td></td><td></td><td></td></tr><tr><td>[t2] - 22</td><td>22</td><td>22</td><td>22</td><td>22</td><td>22</td><td></td><td></td><td></td></tr><tr><td>[t2] - 22</td><td>22</td><td>22</td><td>22</td><td>22</td><td>22</td><td></td><td></td><td></td></tr><tr><td>[t2] - 23</td><td>23</td><td>23</td><td>23</td><td>23</td><td>23</td><td></td><td></td><td></td></tr><tr><td>[t2] - 23</td><td>23</td><td>23</td><td>23</td><td>23</td><td>23</td><td></td><td></td><td></td></tr><tr><td>[t2] - 24</td><td>24</td><td>24</td><td>24</td><td>24</td><td>24</td><td></td><td></td><td></td></tr><tr><td>[t2] - 24</td><td>24</td><td>24</td><td>24</td><td>24</td><td>24</td><td></td><td></td><td></td></tr><tr><td>[t2] - 24</td><td>24</td><td>24</td><td>24</td><td>24</td><td>24</td><td></td><td></td><td></td></tr></table>

```txt
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101  
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101  
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101  
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110011 11111349  
[t2] - 26 6666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666
```

# 批量撤销

当撤销偏向锁阈值超过40次后，jvm会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的

```txt
static Thread t1,t2,t3;   
private static void test4() throws InterruptedException { Vector<Dog> list  $=$  new Vector<>(); int loopNumber  $= 39$  .   
t1  $=$  new Thread(）->{ for (int  $\mathbf{i} = \mathbf{0}$  ;i<loopNumber;i++) { Dog d  $=$  new Dog(); list.add(d); synchronized（d）{ log.debug(i +"\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } } LockSupport.Unpark(t2); }, "t1");   
t1.start();   
t2  $=$  new Thread(）->{ LockSupport.park(); log.debug("===-->"); for (int i  $= 0$  ;i<loopNumber;i++) { Dog d  $=$  list.get(i); log.debug(i +"\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized（d）{ log.debug(i +"\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i +"\t" + ClassLayout.parseInstance(d).toPrintableSimple(true)); } LockSupport.Unpark(t3); }, "t2");
```

```txt
t2.start();   
t3  $=$  new Thread() ->{ LockSupport.park(); log.debug("===-->"); for (int  $\mathrm{i} = 0$  ;i<loopNumber;  $\mathrm{i + + }$  { Dogd  $=$  list.get(i); log.debug(i  $^+$  "\\t"  $^+$  ClassLayout.parseInstance(d).toPrintableSimple(true)); synchronized (d){ log.debug(i  $^+$  "\\t"  $^+$  ClassLayout.parseInstance(d).toPrintableSimple(true)); } log.debug(i  $^+$  "\\t"  $^+$  ClassLayout.parseInstance(d).toPrintableSimple(true)); }，"t3");   
t3.start();   
t3.join();   
log.debug(ClassLayout.parseInstance(new Dog().toPrintableSimple(true));   
}
```

# 参考资料

https://github.com/farmerjohngit/myblog/issues/12

https://www.cnblogs.com/LemonFive/p/11246086.html

https://www.cnblogs.com/LemonFive/p/11248248.html

偏向锁论文

# 5. 锁消除

锁消除

```java
@Fork(1)   
@BenchmarkMode (Mode. AverageTime)   
@Warmup (iterations  $= 3$    
@Measurement (iterations  $= 5$    
@OutputTimeUnit(TimeUnit.NANOSECONDSS)   
public class MyBenchmark { static int  $\mathbf{x} = \mathbf{0}$  . @Benchmark public void a() throws Exception { x++; } @Benchmark public void b() throws Exception { Object o = new Object(); synchronized (o) { x++;
```

```txt
} } 1
```

```batch
java -jar benchmarks.jar
```

```txt
Benchmark Mode Samples Score Score error Units c.i.MyBenchmark.a avgt 5 1.542 0.056 ns/op c.i.MyBenchmark.b avgt 5 1.518 0.091 ns/op
```

```batch
java -XX:-EliminateLocks -jar benchmarks.jar
```

```txt
Benchmark Mode Samples Score Score error Units c.i.MyBenchmark.a avgt 5 1.507 0.108 ns/op c.i.MyBenchmark.b avgt 5 16.976 1.572 ns/op
```

锁粗化

对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。

# wait notify 原理

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751480.jpg)

- Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态
- BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片
- BLOCKED 线程会在 Owner 线程释放锁时唤醒
- WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争

# join 原理

是调用者轮询检查线程 alive 状态

```javascript
t1.join();
```

# 等价于下面的代码

```javascript
synchronized（t1）{ //调用者线程进入t1的waitSet等待，直到t1运行结束 while（t1.isAlive()）{ t1.wait(0); }   
}
```

注意

join 体现的是【保护性暂停】模式，请参考之

# parkunpark原理

每个线程都有自己的一个 Parker 对象，由三部分组成 __counter, __cond 和 __mutex 打个比喻

- 线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1
  为充足）
- 调用 park 就是要看需不需要停下来歇息

如果备用干粮耗尽，那么钻进帐篷歇息  
如果备用干粮充足，那么不需停留，继续前进

- 调用 unpark，就好比令干粮充足

如果这时线程还在帐篷，就唤醒让他继续前进  
如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进

- 因为背包空间有限，多次调用unpark仅会补充一份备用干粮

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751481.jpg)

1. 当前线程调用 Unsafe.park() 方法
2. 检查 counter，本情况为 0，这时，获得 mutex 互斥锁
3. 线程进入 cond 条件变量阻塞
4. 设置 counter = 0

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751482.jpg)

1. 调用 Unsafe.unpark(Thread_0) 方法，设置 counter 为 1
2. 唤醒_cond条件变量中的Thread_0
3. Thread_0 恢复运行
4. 设置 counter 为 0

Unsafe.unpark( Thread 0)

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751483.jpg)

1. 调用 Unsafe.unpark( Thread_0) 方法，设置 counter 为 1
2. 当前线程调用 Unsafe.park() 方法
3. 检查 counter，本情况为 1，这时线程无需阻塞，继续运行
4. 设置 counter 为 0

# AQS 原理

# 1. 概述

全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架

特点：

- 用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁

-o�� -获取state状态  
-o setState - 设置 state 状态  
o compareAndSetState - cas 机制设置 state 状态

- 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源

- 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
- 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet

子类主要实现这样一些方法（默认抛出UnsupportedOperationException）

tryAcquire  
tryRelease  
tryAcquireShared  
tryReleaseShared

- isHeldExclusively

# 获取锁的姿势

// 如果获取锁失败

```javascript
if (!tryAcquire(arg)) { // 入队，可以选择阻塞当前线程 park unpark }
```

# 释放锁的姿势

// 如果释放锁成功

```txt
if (tryRelease(arg)) { // 让阻塞线程恢复运行 }
```

# 2. 实现不可重入锁

# 自定义同步器

```java
final class MySync extends AbstractQueuedSynchronizer {
    @Override
    protected boolean tryAcquire(int acquires) {
        if (acquires == 1) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread( Thread.currentThread());
            }
            return true;
        }
    }
    return false;
}
```

```txt
}
```

# 自定义锁

有了自定义同步器，很容易复用AQS，实现一个功能完备的自定义锁

```java
class MyLock implements Lock{ static MySync sync  $=$  new MySync(); @Override //尝试，不成功，进入等待队列 public void lock() { sync.acquire(1); } @Override //尝试，不成功，进入等待队列，可打断 public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } @Override //尝试一次，不成功返回，不进入队列 public boolean tryLock(){ return sync.tryAcquire(1); } @Override //尝试，不成功，进入等待队列，有时限 publicboolean tryLock(long time,TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1,unit.toNanos(time)); } @Override //释放锁 publicvoid unlock(){ sync.release(1); } @Override //生成条件变量 publicConditionnewCondition(){ return sync.newCondition(); }
```

测试一下

```txt
MyLock lock = new MyLock();
```

```txt
new Thread() -> {
    lock.lock();
    try {
        log.debug("locking...");
        sleep(1);
    } finally {
        log.debug("unlocking...");
        lock.unlock();
    }
}, "t1").start();
new Thread() -> {
    lock.lock();
    try {
        log.debug("locking...");
    } finally {
        log.debug("unlocking...");
        lock.unlock();
    }
}, "t2").start();
```

# 输出

```txt
22:29:28.727 c.TestAqs [t1] - locking...  
22:29:29.732 c.TestAqs [t1] - unlocking...  
22:29:29.732 c.TestAqs [t2] - locking...  
22:29:29.732 c.TestAqs [t2] - unlocking...
```

# 不可重入测试

如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）

```javascript
lock.lock();   
log.debug("locking...");   
lock.lock();   
log.debug("locking...");
```

# 3. 心得

# 起源

早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在JSR166（java规范提案）中创建了AQS，提供了这种通用的同步器机制。

# 目标

AQS 要实现的功能目标

- 阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire
- 获取锁超时机制

通过打断取消机制

- 独占机制及共享机制
- 条件不满足时的等待机制

# 要实现的性能目标

Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when
synchronizers are contended.

# 设计

AQS的基本思想其实很简单

获取锁的逻辑

```txt
while(state状态不允许获取）{if（队列中还没有此线程）{入队并阻塞}  
}  
当前线程出队
```

释放锁的逻辑

```txt
if(state状态允许了）{恢复阻塞的线程(s）}
```

要点

- 原子维护 state 状态
- 阻塞及恢复线程
- 维护队列

1) state 设计

- state 使用 volatile 配合 cas 保证其修改时的原子性
- state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想

2) 阻塞恢复设计

- 早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume 那么 suspend 将感知不到
- 解决方法是使用 park & unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没问题
- park & unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细
- park 线程还可以通过 interrupt 打断

3) 队列设计

- 使用了FIFO先入先出队列，并不支持优先级队列
- 设计时借鉴了 CLH 队列，它是一种单向无锁队列

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751484.jpg)

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751485.jpg)

队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态入队伪代码，只需要考虑
tail 赋值的原子性

出队伪代码

```javascript
do{ //原来的tail Nodeprev  $=$  tail; //用cas在原来tail的基础上改为node }while(tail compareAndSet(prev，node))
```

CLH好处：

```txt
// prev是上一个节点  
while((Node prev=node prevailed).state !=唤醒状态) {  
}  
//设置头节点  
head = node;
```

- 无锁，使用自旋

- 快速，无阻塞

AQS在一些方面改进了CLH

```java
private Node enq(final Node node) {  
    for (;); {  
        Node t = tail;  
        // 队列中还没有元素 tail 为 null  
        if (t == null) {  
            // 将 head 从 null -> dummy  
            if (compareAndSetHead(new Node()))  
                tail = head;  
        } else {  
            // 将 node 的 prev 设置为原来的 tail  
            node prevailed = t;  
            // 将 tail 从原来的 tail 设置为 node  
            if (compareAndSetTail(t, node)) {  
                // 原来 tail 的 next 设置为 node  
                t.next = node;  
                return t;  
            }  
        }  
    }
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751486.jpg)  
主要用到AQS的并发工具类

# ReentrantLock 原理

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751487.jpg)

# 1.非公平锁实现原理

# 加锁解锁流程

先从构造器开始看，默认为非公平锁实现

```java
public ReentrantLock() { sync = new NonfairSync(); }
```

NonfairSync 继承自 AQS

没有竞争时

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751488.jpg)

第一个竞争出现时

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751489.jpg)

# Thread-1 执行了

1. CAS 尝试将 state 由 0 改为 1，结果失败
2. 进入tryAcquire逻辑，这时state已经是1，结果仍然失败
3. 接下来进入 addWaiter 逻辑，构造 Node 队列

图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态  
Node 的创建是懒惰的  
。其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751490.jpg)

# 当前线程进入acquireQueued逻辑

1. acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞
2. 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败
3. 进入shouldParkAfterFailedAcquire逻辑，将前驱node，即head的waitStatus改为-1，这次返回false

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751491.jpg)

4. shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败
5. 当再次进入shouldParkAfterFailedAcquire时，这时因为其前驱node的waitStatus已经是-1，这次返回true
6. 进入 parkAndCheckInterrupt，Thread-1 park（灰色表示）

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751492.jpg)

再次有多个线程经历上述过程竞争失败，变成这个样子

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751493.jpg)

Thread-0 释放锁，进入 tryRelease 流程，如果成功

- 设置 exclusiveOwnerThread 为 null  
  state  $= 0$

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751494.jpg)

当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程

找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1

回到 Thread-1 的 acquireQueued 流程

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751495.jpg)

如果加锁成功（没有竞争），会设置

- exclusiveOwnerThread 为 Thread-1, state = 1
- head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread
- 原本的 head 因为从链表断开，而可被垃圾回收

如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751496.jpg)

如果不巧又被 Thread-4 占了先

- Thread-4 被设置为 exclusiveOwnerThread, state = 1
- Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞

# 加锁源码

```txt
// Sync 继承自 AQS  
static final class NonfairSync extends Sync {  
    private static final long serialVersionUID = 7316153563782823691L;  
    // 加锁实现
```

```txt
final void lock() { //首先用cas尝试（仅尝试一次）将state从0改为1，如果成功表示获得了独占锁 if (compareAndSetState(0,1)) setExclusiveOwnerThread( Thread.currentThread()); else //如果尝试失败，进入（acquire(1); } //  $\Lsh$  AQS继承过来的方法，方便阅读，放在此处   
public final void acquire(int arg) { //  $\Lsh$  tryAcquire if ( !tryAcquire(arg)&& //当tryAcquire返回为false时，先调用addWaiter四，接着acquireQueued四 acquireQueued(addWaiter(Node.EXCLUSIVE)，arg) ）{ selfInterrupt(); }   
}   
//  $\Lsh$  进入  
protected final boolean tryAcquire(int acquires){ return nonfairTryAcquire(acquires);   
}   
// Sync继承过来的方法，方便阅读，放在此处   
final boolean nonfairTryAcquire(int acquires){ final Thread current  $=$  Thread.currentThread(); int c  $=$  getState(); //如果还没有获得锁 if  $(c = = 0)$  { //尝试用cas获得，这里体现了非公平性：不去检查AQS队列 if (compareAndSetState(0,acquires)){ setExclusiveOwnerThread(current); return true; } }   
//如果已经获得了锁，线程还是当前线程，表示发生了锁重入 else if(current  $= =$  getExclusiveOwnerThread()){ //state++ int nextc  $= c +$  acquires; if(nextc<0)//overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; } //获取失败，回到调用处 return false;   
}   
//AQS继承过来的方法，方便阅读，放在此处   
private Node addWaiter(Node mode) {
```

```txt
//将当前线程关联到一个Node对象上，模式为独占模式
Node node = new Node( Thread.currentThread(), mode);
//如果tail不为null，cas尝试将Node对象加入AQS队列尾部
Node pred = tail;
if (pred != null) {
    node prevailed = pred;
    if (compareAndSetTail(pred, node)) {
        //双向链表
        pred.next = node;
        return node;
    }
}
//尝试将Node加入AQS，进入六
eng(node);
return node;
```

// (AQS 继承过来的方法，方便阅读，放在此处

```java
private Node enq(final Node node) {  
    for (;;) {  
        Node t = tail;  
        if (t == null) {  
            // 还没有，设置 head 为哨兵节点（不对应线程，状态为0）  
            if (compareAndSetHead(new Node())) {  
                tail = head;  
            }  
        } else {  
            // cas 尝试将 Node 对象加入 AQS 队列尾部  
            nodeprev = t;  
            if (compareAndSetTail(t, node)) {  
                t.next = node;  
                return t;  
            }  
        }  
    }
```

// (五) AQS 继承过来的方法，方便阅读，放在此处

```txt
final boolean acquireQueued(final Node node, int arg) {
boolean failed = true;
try {
boolean interrupted = false;
for (;); {
final Node p = node.predecessor();
// 上一个节点是 head，表示轮到自己（当前线程对应的 node）了，尝试获取
if (p == head && tryAcquire(arg)) {
// 获取成功，设置自己（当前线程对应的 node）为 head
setHead(node);
// 上一个节点 help GC
p.next = null;
failed = false;
// 返回中断标记 false
return interrupted;
}
```

```javascript
} if（ //判断是否应当park，进入） shouldParkAfterFailedAcquire(p,node）&& //park等待，此时Node的状态被置为Node.SIGNAL（） parkAndCheckInterrupt() } { interrupted  $=$  true; 1 } } finally{ if(failed) cancelAcquire(node);   
}
```

// (七) AQS 继承过来的方法，方便阅读，放在此处

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { //获取上一个节点的状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) { //上一个节点都在阻塞，那么自己也阻塞好了 return true; } // >0 表示取消状态 if (ws > 0) { //上一个节点取消，那么重构删除前面所有取消的节点，返回到外层循环重试 do { node prevail = pred = pred prevail; } while (pred.waitStatus > 0); pred.next = node; } else { //这次还没有阻塞 //但下次如果重试不成功，则需要阻塞，这时需要设置上一个节点状态为Node.SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; }   
//阻塞当前线程 private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); }
```

# 注意

- 是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定

# 解锁源码

// Sync 继承自 AQS

```txt
static final class NonfairSync extends Sync{ //解锁实现 public void unlock() { sync.release(1); } //AQS继承过来的方法，方便阅读，放在此处 public final boolean release(int arg){ //尝试释放锁，进入（） if（tryRelease(arg)）{//队列头节点unpark Nodeh  $=$  head; if（ //队列不为null h!  $\equiv$  null&& // waitStatus  $\equiv =$  Node.SIGNAL才需要unpark h.waitStatus！  $= 0$  ）{ //unparkAQS中等待的线程，进入（） unparkSuccessor(h); } return true; } return false;
```

//  $\leftarrow$  Sync 继承过来的方法，方便阅读，放在此处

```txt
protected final boolean tryRelease(int releases) { // state-- int c =boseState() - releases; if (Thread.currentThread(   ) != getExclusiveOwnerThread(   )) throw new IllegalMonitorStateExceptionException(); boolean free  $=$  false; // 支持锁重入, 只有 state 减为 0 , 才释放成功 if (c == 0) \{ free  $=$  true; setExclusiveOwnerThread(null); }SETS(c); return free;   
}
```

//  $\Leftrightarrow$  AQS 继承过来的方法，方便阅读，放在此处

```txt
private void unparkSuccessor(Node node) { //如果状态为Node.SIGNAL尝试重置状态为0 //不成功也可以 int ws  $=$  node.waitStatus; if  $(\mathrm{ws} <   0)$  { compareAndSetWaitStatus(node,ws,0); }
```

```txt
// 找到需要 unpark 的节点，但本节点从 AQS 队列中脱离，是由唤醒节点完成的
```

```javascript
Node s = node.next; // 不考虑已取消的节点，从 AQs 队列从后至前找到队列最前面需要 unpark 的节点 if (s == null || s.waitStatus > 0) { s = null; for (Node t = tail; t != null && t != node; t = tprev) if (t.waitStatus <= 0) s = t; } if (s != null) LockSupport.Unpark(s.thread); }
```

# 2. 可重入原理

```txt
static final class NonfairSync extends Sync { // ...
```

// Sync 继承过来的方法，方便阅读，放在此处

```txt
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c =bose;
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
} //如果已经获得了锁，线程还是当前线程，表示发生了锁重入
else if (current == getExclusiveOwnerThread())
{
    // state++
    int nextc = c + acquires;
    if (nextc < 0) // overflow
        throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
} 
return false;
```

// Sync 继承过来的方法，方便阅读，放在此处

```txt
protected final boolean tryRelease(int releases) { // state-- int c =boseState() - releases; if (Thread.currentThread(   ) != getExclusiveOwnerThread(   )) throw new IllegalMonitorStateExceptionException(   ); boolean free  $=$  false; // 支持锁重入,只有 state 减为 0 , 才释放成功 if (c == 0) \{ free  $=$  true; setExclusiveOwnerThread(null); }
```

```txt
setState(c); return free; } 1
```

# 3. 可打断原理

# 不可打断模式

在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了

```java
// Sync 继承自 AQS  
static final class NonfairSync extends Sync {  
// ...  
private final boolean parkAndCheckInterrupt() {  
// 如果打断标记已经是 true，则 park 会失效  
LockSupport.park(this);  
// interrupted 会清除打断标记  
return Thread.interrupted();  
}  
final boolean acquireQueued(final Node node, int arg) {  
boolean failed = true;  
try {  
boolean interrupted = false;  
for (;); {  
final Node p = node.predecessor();  
if (p == head && tryAcquire(arg)) {  
setHead(node);  
p.next = null;  
failed = false;  
// 还是需要获得锁后，才能返回打断状态  
return interrupted;  
}  
if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) {  
// 如果是因为 interrupt 被唤醒，返回打断状态为 true  
interrupted = true;  
}  
}  
}finally {  
if (failed)  
cancelAcquire(node);  
}  
public final void acquire(int arg) {
```

```txt
if (
!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
) {
// 如果打断状态为 true
selfInterrupt();
}
}
```

# 可打断模式

```java
static final class NonfairSync extends Sync {
public final void acquireInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 如果没有获得到锁，进入()
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
} // (→) 可打断的获取锁流程
private void doAcquireInterruptibly(int arg) throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                // 在 park 过程中如果被 interrupt 会进入此
                // 这时候抛出异常，而不会再次进入 for (;);
                throw new错了Exception();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
}
```

# 4. 公平锁实现原理

static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L;

```txt
final void lock() { acquire(1); }
```

// AQS 继承过来的方法，方便阅读，放在此处

```txt
public final void acquire(int arg) { if ( !tryAcquire(arg)&& acquireQueued(addWaiter(Node.EXCLUSIVE),arg) ）{ selfInterrupt(); }   
}
```

// 与非公平锁主要区别在于 tryAcquire 方法的实现

```javascript
protected final boolean tryAcquire(int acquires) {final Thread current  $=$  Thread.currentThread();int c  $=$ boseState();if  $(c = =0)$  {//先检查AQS队列中是否有前驱节点，没有才去竞争if(!hasQueuedPredecessors()&&compareAndSetState(0,acquires)){setExclusiveOwnerThread(current);return true;1}else if(current  $= =$  getExclusiveOwnerThread()){int nextc  $=$  c  $^+$  acquires;if(nextc<0)throw new Error("Maximum lock count exceeded");setState(nextc);return true;1return false;
```

// (AQS 继承过来的方法，方便阅读，放在此处)

```txt
public final boolean hasQueuedPredecessors() { Node t = tail; Node h = head; Node s; //h!  $\equiv$  t时表示队列中有Node return h!  $\equiv$  t&& （//（s=h.next）  $= =$  null表示队列中还有没有老二 (s=h.next)  $= =$  null
```

```javascript
//或者队列中老二线程不是此线程s.thread != Thread.currentThread()）;1
```

# 5. 条件变量实现原理

每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject

# await流程

开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程

创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751497.jpg)

接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751498.jpg)

unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751499.jpg)  
park 阻塞 Thread-0

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751500.jpg)  
假设 Thread-1 要来唤醒 Thread-0

# signal流程

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751501.jpg)  
进入ConditionObject的doSignal流程，取得等待队列中第一个Node，即Thread-0所在Node

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751502.jpg)

执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751503.jpg)

Thread-1 释放锁，进入 unlock 流程，略

# 源码

```java
public class ConditionObject implements Condition,java.io.Serializable{ private static final long serialversionUID  $=$  1173984872572414699L; //第一个等待节点 private transient Node firstWaiter; //最后一个等待节点 private transient Node lastWaiter; public ConditionObject(){ //  $\leftarrow$  添加一个Node至等待队列 private Node addConditionWaiter() { Node t  $=$  lastWaiter; //所有已取消的Node从队列链表删除，见  $\leftarrow$
```

```javascript
if (t != null && t.waitStatus != Node.CONDITION) { unlinkCancelledWaiters(); t = lastWaiter; } //创建一个关联当前线程的新Node，添加至队列尾部 Node node = new Node( Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node; } //唤醒 - 将没取消的第一个节点转移至AQS队列 private void doSignal(Node first) { do { //已经是尾节点了 if ((firstWaiter = first.nextWaiter) == null) { lastWaiter = null; } first.nextWaiter = null; } while ( //将等待队列中的Node转移至AQS队列，不成功且还有节点则继续循环（）!transferForSignal(first) && //队列还有节点 (first = firstWaiter) != null ); } //外部类方法，方便阅读，放在此处 //（如果节点状态是取消，返回false表示转移失败，否则转移成功 final boolean transferForSignal(Node node) { //如果状态已经不是Node.CONDITION，说明被取消了 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //加入AQS队列尾部 Node p = enq(node); int ws = p.waitStatus; if ( //上一个节点被取消 ws > 0 || //上一个节点不能设置状态为Node.SIGNAL !compareAndSetWaitStatus(p, ws, Node.SIGNAL) } { // unpark取消阻塞，让线程重新同步状态 LockSupport.unpark(nodethread); } return true; } //全部唤醒 - 等待队列的所有节点转移至AQS队列
```

```java
private void doSignalAll(Node first) {lastWaiter  $=$  firstWaiter  $=$  null;do{Node next  $=$  first.nextWaiter;first.nextWaiter  $=$  null;transferForSignal(first);first  $=$  next;1while (first  $! =$  null);   
}   
//  $\Leftrightarrow$  private void unlinkCancelledWaiters(){//...   
}   
//唤醒-必须持有锁才能唤醒，因此doSignal内无需考虑加锁public final void signal(){if(!isHeldExclusively()){throw new IllegalMonitorStateExceptionException();Node first  $=$  firstWaiter;if(first  $! =$  null)doSignal(first);   
}   
//全部唤醒-必须持有锁才能唤醒，因此doSignalAll内无需考publicfinalvoid signalAll(){if(!isHeldExclusively()){throw new IllegalMonitorStateExceptionException();Node first  $=$  firstWaiter;if(first  $! =$  null)doSignalAll(first);   
}   
//不可打断等待-直到被唤醒public final void awaitUninterruptibly() {//添加一个Node至等待队列，见（）Node node  $=$  addConditionWaiter();//释放节点持有的锁，见四int savedState  $=$  fullyRelease(node);boolean interrupted  $=$  false;//如果该节点还没有转移至AQS队列，阻塞while(!isOnSyncQueue(node)){//park阻塞LockSupport.park(this);//如果被打断，仅设置打断状态if (Thread.interrupted())interrupted  $=$  true;1//唤醒后，尝试竞争锁，如果失败进入AQS队列if(acquireQueued(node,savedState)||interrupted)selfInterrupt();
```

// 外部类方法，方便阅读，放在此处

```javascript
// 四因为某线程可能重入，需要将state全部释放  
final int fullyRelease(Node node) {boolean failed  $=$  true;try{int savedState  $\equiv$  getState();if (release(sAVEDState)){failed  $=$  false;return savedState;}else{throw new IllegalMonitorStateExceptionException();1}finally{if(failed)node.waitStatus  $\equiv$  Node.CANCELLED;1}
```

// 打断模式 - 在退出等待时重新设置打断状态

```java
private static final int REINTERRUPT = 1; //打断模式 - 在退出等待时抛出异常 private static final int THROW_IE = -1;
```

// 判断打断模式

```java
private int checkInterruptWhileWaiting(Node node) { return Thread.interrupted(); (transferAfterCancelledWait(node)? THROW_IE:REINTERRUPT): 0;   
}
```

//（五）应用打断模式

```java
private void reportInterruptAfterWait(int interruptMode) throws InterruptedException { if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt(); }
```

// 等待 - 直到被唤醒或打断

```javascript
public final void await() throws InterruptedException{ if (Thread.interrupted()){ throw new扰乱Exception(); } //添加一个Node至等待队列，见  $\langle \rangle$  Node node  $=$  addConditionWaiter(); //释放节点持有的锁 int savedState  $=$  fullyRelease(node); int interruptMode  $= 0$  . //如果该节点还没有转移至AQS队列，阻塞 while(!isOnSyncQueue(node)){ //park阻塞 LockSupport.park(this);
```

```txt
// 如果被打断，退出等待队列
if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
break;
}
// 退出等待队列后，还需要获得 AQS 队列的锁
if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
interruptMode = REINTERRUPT;
// 所有已取消的 Node 从队列链表删除，见
if (node.nextWaiter != null)
unlinkCancelledWaiters();
// 应用打断模式，见
if (interruptMode != 0)
reportInterruptAfterWait(interruptMode);
}
// 等待 - 直到被唤醒或打断或超时
public final long awaitNanos(long nanosTimeout) throws InterruptedException {
if (Thread.interrupted())
throw new InterruptedException();
}
// 添加一个 Node 至等待队列，见
Node node = addConditionWaiter();
// 释放节点持有的锁
int savedState = fullyRelease(node);
// 获得最后期限
final long deadline = System.nanoTime() + nanosTimeout;
int interruptMode = 0;
// 如果该节点还没有转移至 AQS 队列，阻塞
while (!isOnSyncQueue(node)) {
// 已超时，退出等待队列
if (nanosTimeout <= 0L) {
transferAfterCancelledWait(node);
break;
}
// park 阻塞一定时间，spinForTimeoutThreshold 为 1000 ns
if (nanosTimeout >= spinForTimeoutThreshold)
LockSupport.parkNanos(this, nanosTimeout);
// 如果被打断，退出等待队列
if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
break;
nanosTimeout = deadline - System.nanoTime());
}
// 退出等待队列后，还需要获得 AQS 队列的锁
if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
interruptMode = REINTERRUPT;
// 所有已取消的 Node 从队列链表删除，见
if (node.nextWaiter != null)
unlinkCancelledWaiters();
// 应用打断模式，见
if (interruptMode != 0)
reportInterruptAfter Wait(interruptMode);
return deadline - System.nanoTime();
}
```

```java
//等待-直到被唤醒或打断或超时，逻辑类似于awaitNanos public final boolean awaitUntil(Date deadline) throws InterruptedException { //... } //等待-直到被唤醒或打断或超时，逻辑类似于awaitNanos public final boolean await(long time, TimeUnit unit) throws InterruptedException { //... } //工具方法省略... }
```

# 读写锁原理

# 1. 图解流程

读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个

# t1 w.lock , t2 r.lock

1）t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16
位

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751504.jpg)

2）t2执行r.lock，这时进入读锁的sync.acquireShared(1)流程，首先会进入tryAcquireShared流程。如果有写锁占据，那么tryAcquireShared返回-1表示失败

tryAcquireShared 返回值表示

- 1 表示失败

- 0 表示成功，但后继节点不会继续唤醒
- 正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751505.jpg)

3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为 Node.SHARED 模式而非
Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751506.jpg)

4) t2 会看看自己的节点是不是老二, 如果是, 还会再次调用 tryAcquireShared(1) 来尝试获取锁  
   5）如果没有成功，在doAcquireShared内for(;;)循环一次，把前驱节点的waitStatus改为-1，再for(;;)循环一次尝试tryAcquireShared(
   1)如果还不成功，那么在parkAndCheckInterrupt()处park

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751507.jpg)

# t3 r.lock , t4 w.lock

这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751508.jpg)

# t1 w.unlock

这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751509.jpg)

接下来执行唤醒流程 sync.UnparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行

这回再来一次 for (;) 执行 tryAcquireShared 成功则让读锁计数加一

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751510.jpg)  
这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751511.jpg)  
事情还没完，在setHeadAndPropagate方法内还会检查下一个节点是否是shared，如果是则调用doReleaseShared()
将head的状态从-1改为0并唤醒老二，这时t3在doAcquireShared内parkAndCheckInterrupt()处恢复运行

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751512.jpg)  
这回再来一次 for (;) 执行 tryAcquireShared 成功则让读锁计数加一

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751513.jpg)

这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751514.jpg)

下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点

# t2 r.unlock , t3 r.unlock

t2进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，但由于计数还不为零

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751515.jpg)

t3进入sync.releaseShared(1)中，调用tryReleaseShared(1)让计数减一，这回计数为零了，进入doReleaseShared()将头节点从-1改为0并唤醒老二，即

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751516.jpg)

之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1)
成功，修改头结点，流程结束

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751517.jpg)

# 2. 源码分析

# 写锁上锁流程

```java
static final class NonfairSync extends Sync{ //...省略无关代码   
//外部类WriteLock方法，方便阅读，放在此处 public void lock(){ sync.acquire(1);   
}   
//AQS继承过来的方法，方便阅读，放在此处   
public final void acquire(int arg){ if（ //尝试获得写锁失败 !tryAcquire(arg)&& //将当前线程关联到一个Node对象上，模式为独占模式 //进入AQS队列阻塞 acquireQueued(addWaiter(Node.EXCLUSIVE)，arg) ）{ selfInterrupt();   
}   
//Sync继承过来的方法，方便阅读，放在此处 protectedfinalbooleantryAcquire(intacquires){ //获得低16位，代表写锁的state计数 Threadcurrent  $=$  Thread.currentThread(); intc  $\equiv$  getState();
```

```txt
int w = exclusiveCount(c);  
if (c != 0) {  
    if (  
        // c != 0 and w == 0 表示有读锁，或者  
        w == 0 ||  
        // 如果 exclusiveOwnerThread 不是自己  
        current != getExclusiveOwnerThread()  
    ) {  
        // 获得锁失败  
        return false;  
    }  
// 写锁计数超过低16位，报异常  
if (w + exclusiveCount(acquires) > MAX_COUNT)  
    throw new Error("Maximum lock count exceeded");  
// 写锁重入，获得锁成功  
setState(c + acquires);  
return true;  
}  
if (  
    // 判断写锁是否该阻塞，或者  
    writerShouldBlock() ||  
    // 尝试更改计数失败  
!compareAndSetState(c, c + acquires)  
} {  
    // 获得锁失败  
    return false;  
}  
// 获得锁成功  
setExclusiveOwnerThread(current);  
return true;  
}  
// 非公平锁 writerShouldBlock 总是返回 false，无需阻塞  
final boolean writerShouldBlock() {  
    return false;  
}
```

# 写锁释放流程

```txt
static final class NonfairSync extends Sync{ //...省略无关代码 //WriteLock方法，方便阅读，放在此处 public void unlock(){ sync.release(1); } //AQS继承过来的方法，方便阅读，放在此处 public final boolean release(int arg){ //尝试释放写锁成功
```

```javascript
if (tryRelease(arg)){ //unpark AQS中等待的线程 Node h = head; if（h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false;   
//Sync继承过来的方法，方便阅读，放在此处 protected final boolean tryRelease(int releases){ if(!isHeldExclusively()) throw new IllegalMonitorStateExceptionException(); int nextc  $=$  getState() - releases; //因为可重入的原因，写锁计数为0，才算释放成功 boolean free  $=$  exclusiveCount(nextc）  $= =$  0; if(free){ setExclusiveOwnerThread(null); }SETSnextc); return free;   
}
```

# 读锁上锁流程

```java
static final class NonfairSync extends Sync {
    // ReadLock 方法，方便阅读，放在此处
    public void lock() {
        sync.acquireShared(1);
    }
    // AQS 继承过来的方法，方便阅读，放在此处
    public final void acquireShared(int arg) {
        // tryAcquireShared 返回负数，表示获取读锁失败
        if (tryAcquireShared(arg) < 0) {
            doAcquireShared(arg);
        }
    }
}
```

```txt
}  
int r = sharedCount(c);  
if (  
// 读锁不该阻塞(如果老二是写锁，读锁该阻塞)，并且！readerShouldBlock() &&  
// 小于读锁计数，并且  
r < MAX_COUNT &&  
// 尝试增加计数成功  
compareAndSetState(c, c + SHARED_UNIT)  
）{  
// ... 省略不重要的代码  
return 1;  
}  
return fullTryAcquireShared(current);
```

// 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁

// true 则该阻塞，false 则不阻塞

```txt
final boolean readerShouldBlock() {
return apparentlyFirstQueuedIsExclusive();
}
```

// AQS 继承过来的方法，方便阅读，放在此处

// 与tryAcquireShared功能类似，但会不断尝试for（;；）获取读锁，执行过程中无阻塞

```javascript
final int fullTryAcquireShared Thread current) { HoldCounter rh = null; for (;;) { int c = getState(); if (exclusiveCount(c) != 0) { if (getExclusiveOwnerThread() != current) return -1; } else if (readerShouldBlock()) { // ... 省略不重要的代码 } if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); if (compareAndSetState(c, c + SHARED_UNIT)) { // ... 省略不重要的代码 return 1; } } }
```

// AQS 继承过来的方法，方便阅读，放在此处

```java
private void doAcquireShared(int arg) { //将当前线程关联到一个Node对象上，模式为共享模式 final Node node  $=$  addWaiter(Node.SHARED); boolean failed  $=$  true; try { boolean interrupted  $=$  false; for(;;){ final Node  $\mathfrak{p} =$  node.predecessor(); if  $(\mathsf{p} ==$  head）{
```

```javascript
//再一次尝试获取读锁int  $\mathbf{r} =$  tryAcquireShared(arg); //成功if  $(\textsf{r} >=\textsf{0})$  {//  $\leftarrow$  //r表示可用资源数，在这里总是1允许传播//（唤醒AQS中下一个Share节点）setHeadAndPropagate(node,r);p.next  $=$  null; //help GCif (interrupted)selfInterrupt();failed  $=$  false;return;1}if(//是否在获取读锁失败时阻塞（前一个阶段waitStatus  $\equiv =$  Node.SIGNAL）shouldParkAfterFailedAcquire(p,node)&&//park当前线程parkAndCheckInterrupt()）{interrupted  $=$  true;1}1}finally{if(failed)cancelAcquire(node);1}  
//  $\Lsh$  AQS继承过来的方法，方便阅读，放在此处private void setHeadAndPropagate(Node node,intpropagate){Nodeh  $=$  head; //Record old head for check below//设置自己为headsetHead(node);//propagate表示有共享资源（例如共享读锁或信号量）//原head waitStatus  $\equiv =$  Node.SIGNAL或Node.PROPGATE//现在head waitStatus  $\equiv =$  Node.SIGNAL或Node.PROPGATEif(propagate  $>0||h==nul1||h.waitStatus<0||$  （20号  $(\mathrm{h} =$  head）  $= =$  null||h.waitStatus  $<  0$  1  $\mathrm{(h =}$  head）  $= =$  null||h.waitStatus  $<  0$  ）{Node s  $=$  node.next;//如果是最后一个节点或者是等待共享读锁的节点if(s  $= =$  null||s.isShared()){//进入doReleaseShared();1}1  
//  $\Lsh$  AQS继承过来的方法，方便阅读，放在此处privatevoiddoReleaseShared(){
```

```javascript
//如果head.waitStatus  $= = 0 = = >$  Node.PROPAGATE，为了解决bug，见后面分析  
for（;）{Nodeh  $\equiv$  head;  
//队列还有节点if（h！  $\equiv$  null&&h！  $\equiv$  tail）{intws  $\equiv$  h.waitStatus;if（ws  $\equiv =$  Node.SIGNAL）{if(!compareAndSetWaitStatus(h，Node.SIGNAL，0))continue; // loop to recheck cases//下一个节点unpark如果成功获取读锁//并且下下个节点还是shared，继续doReleaseSharedunparkSuccessor(h);1else if（ws  $\equiv = 0\& \&$  !compareAndSetWaitStatus(h，0，Node.PROPAGATE)）continue; // loop on failed CAS}if（h  $\equiv =$  head) // loop if head changedbreak;1
```

# 读锁释放流程

```javascript
static final class NonfairSync extends Sync{ //ReadLock方法，方便阅读，放在此处 public void unlock(){ sync.releaseShared(1); } //AQS继承过来的方法，方便阅读，放在此处 publicfinalbooleanreleaseShared(intarg){ if（tryReleaseShared(arg)){ doReleaseShared(); return true; } return false; } //Sync继承过来的方法，方便阅读，放在此处 protectedfinalbooleantryReleaseShared(intunused）{ //...省略不重要的代码 for（）{ intc  $\equiv$  getState(); intnextc  $=$  c-SHARED_UNIT; if(compareAndSetState(c,nextc)) { //读锁的计数不会影响其它获取读锁线程，但会影响其它获取写锁线程 //计数为0才是真正释放 return nextc  $= = 0$  1
```

```javascript
}   
}   
//AQS继承过来的方法，方便阅读，放在此处   
private void doReleaseShared() { //如果head.waitStatus  $= =$  Node.SIGNAL  $\equiv = >0$  成功，下一个节点unpark //如果head.waitStatus  $= = 0 = = >$  Node.PROPGATE for（;）{ Node h  $=$  head; if（h！  $= =$  null&&h！  $= =$  tail）{ int ws  $=$  h.waitStatus; //如果有其它线程也在释放读锁，那么需要将waitStatus先改为0 //防止unparkSuccessor被多次执行 if（ws  $= =$  Node.SIGNAL）{ if(!compareAndSetWaitStatus(h,Node.SIGNAL,0)) continue; // loop to recheck cases unparkSuccessor(h); } //如果已经是0了，改为-3，用来解决传播性，见后文信号量bug分析 elseif（ws  $= = 0\& \&$  !compareAndSetWaitStatus(h,0,Node.PROPGATE)) continue; // loop on failed CAS } if（h  $= =$  head) // loop if head changed break; } }
```

# Semaphore 原理

# 1. 加锁解锁流程

Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一

刚开始，permits（state）为3，这时5个线程来获取资源

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751518.jpg)

假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751519.jpg)

这时 Thread-4 释放了 permits，状态如下

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751520.jpg)

接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于
permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态

Thread-1

Thread-2

Thread-0

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751521.jpg)

# 2. 源码分析

```java
static final class NonfairSync extends Sync { private static final long serialversionUID  $=$  -2694183684443567898L; NonfairSync(int permits){ //permits即state super(permits); }
```

//Semaphore 方法，方便阅读，放在此处

```java
public void acquire() throws InterruptedException { sync.acquireSharedInterruptibly(1); }
```

// AQ5 继承过来的方法，方便阅读，放在此处

```java
public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new扰乱Exception(); if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg); }
```

// 尝试获得共享锁

```txt
protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); }
```

// Sync 继承过来的方法，方便阅读，放在此处

```txt
final int nonfairTryAcquireShared(int acquires) {  
    for (;); {  
        int available = getState();  
        int remaining = available - acquires;  
    }  
    if ( // 如果许可已经用完，返回负数，表示获取失败，进入 doAcquireSharedInterruptibly remaining < 0 || // 如果 cas 重试成功，返回正数，表示获取成功 compareAndSetState-available, remaining)
```

```txt
1）{ return remaining; } 1
```

// AQS 继承过来的方法，方便阅读，放在此处

```txt
private void doAcquireSharedInterruptibly(int arg) throws InterruptedException{ final Node node  $=$  addWaiter(Node.SHARED); boolean failed  $=$  true; try { for(;;){ final Node  $\mathsf{p} =$  node.predecessor(); if  $(\mathsf{p} = =$  head）{//再次尝试获取许可 int r  $=$  tryAcquireShared(arg); if  $(r >= 0)$  { //成功后本线程出队（AQS），所在Node设置为head //如果head.waitStatus  $= =$  Node.SIGNAL  $= = >0$  成功，下一个节点unpark //如果head.waitStatus  $= = 0 = = >$  Node.PROPAGATE //r表示可用资源数，为0则不会继续传播 setHeadAndPropagate(node,r); p.next  $=$  null; //help GC failed  $=$  false; return; } } //不成功，设置上一个节点waitStatus  $=$  Node.SIGNAL，下轮进入park阻塞 if (shouldParkAfterFailedAcquire(p,node)&& parkAndCheckInterrupt()) throw new错了Exception(); } }finally{ if(failed) cancelAcquire(node); }
```

//Semaphore 方法，方便阅读，放在此处

```txt
public void release() { sync.releaseShared(1); }
```

// AQ5 继承过来的方法，方便阅读，放在此处  
// Sync 继承过来的方法，方便阅读，放在此处

```java
public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; }
```

```javascript
protected final boolean tryReleaseShared(int releases) { for (;;){ int current  $=$ boseState(); int next  $=$  current  $^+$  releases; if (next  $<$  current) // overflow throw new Error("Maximum permit count exceeded"); if (compareAndSetState(current, next)) return true; } }
```

# 3. 为什么要有 PROPAGATE

早期有bug

- releaseShared 方法

```txt
public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; }
```

- doAcquireShared 方法

```javascript
private void doAcquireShared(int arg) { final Node node  $=$  addWaiter(Node.SHARED); boolean failed  $=$  true; try { boolean interrupted  $=$  false; for (;;){ final Node p  $=$  node.predecessor(); if  $(\mathfrak{p} = =$  head）{ int r  $=$  tryAcquireShared(arg); if  $(r >= 0)$  { //这里会有空档 setHeadAndPropagate(node,r); p.next  $=$  null; // help GC if (interrupted) selfInterrupt(); failed  $=$  false; return; } } if (shouldParkAfterFailedAcquire(p,node)&& parkAndCheckInterrupt())
```

```javascript
interrupted  $=$  true; } }finally{ if(failed) cancelAcquire(node); 1
```

- setHeadAndPropagate 方法

```javascript
private void setHeadAndPropagate(Node node, int propagate) {setHead(node);//有空闲资源if(propagate  $>0$  &&node.waitStatus  $! = 0$  ）{Node s  $=$  node.next;//下一个if(s  $= =$  null||s.isShared())unparkSuccessor(node);1
```

- 假设存在某次循环中队列里排队的结点情况为 head(-1) -> t1(-1) -> t2(-1)
- 假设存在将要信号量释放的 T3 和 T4，释放顺序为先 T3 后 T4

# 正常流程

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751522.jpg)

# 产生bug的情况

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751523.jpg)

# 修复前版本执行流程

1. T3 调用 releaseShared(1)，直接调用了 unparkSuccessor(head)，head 的等待状态从 -1 变为 0
2. T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，假设返回值为 0（获取锁成功，但没有剩余资源量）
3. T4 调用 releaseShared(1)，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个head），不满足条件，因此不调用
   unparkSuccessor(head)
4. T1 获取信号量成功，调用 setHeadAndPropagate 时，因为不满足 propagate > 0（2 的返回值也就是 propagate（剩余资源量） ==
   0），从而不会唤醒后继结点，T2 线程得不到唤醒

# bug修复后

```java
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    // 设置自己为 head
    setHead(node);
    // propagate 表示有共享资源（例如共享读锁或信号量）
    // 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE
    // 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE
    if (propagate > 0 || h == null || h.waitStatus < 0 || (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        // 如果是最后一个节点或者是等待共享读锁的节点
        if (s == null || s.isShared()) {
            doReleaseShared();
        }
    }
}
```

```txt
if (ws == Node.SIGNAL) { if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS } if (h == head) // loop if head changed break; } }
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751524.jpg)

1. T3 调用 releaseShared(), 直接调用了 unparkSuccessor(head), head 的等待状态从 -1 变为 0
2. T1 由于 T3 释放信号量被唤醒，调用 tryAcquireShared，假设返回值为 0（获取锁成功，但没有剩余资源量）
3. T4 调用 releaseShared()，此时 head.waitStatus 为 0（此时读到的 head 和 1 中为同一个 head），调用 doReleaseShared()
   将等待状态置为 PROPAGATE (-3)
4. T1 获取信号量成功，调用 setHeadAndPropagate 时，读到 h.waitStatus < 0，从而调用 doReleaseShared() 唤醒 T2

# ConcurrentHashMap 原理

# 1. JDK 7 HashMap 并发死链

# 测试代码

注意

要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了

- 以下测试代码是精心准备的，不要随便改动

```java
public static void main(String[] args) { //测试java7中哪些数字的hash结果相等 System.out.println("长度为16时，桶下标为1的key"); for (int i = 0; i < 64; i++) { if (hash(i) % 16 == 1) { System.out.println(i); } } System.out.println("长度为32时，桶下标为1的key"); for (int i = 0; i < 64; i++) { if (hash(i) % 32 == 1) { System.out.println(i); } } //1,35,16,50当大小为16时，它们在一个桶内 final HashMapInteger, Integer> map = new HashMapInteger, Integer>(); //放12个元素 map.put(2,null); map.put(3,null); map.put(4,null); map.put(5,null); map.put(6,null); map.put(7,null); map.put(8,null); map.put(9,null); map.put(10,null); map.put(16,null); map.put(35,null); map.put(1,null); System.out.println("扩容前大小[main]:" + map.size()); new Thread() { @Override public void run() { //放第13个元素，发生扩容 map.put(50,null); System.out.println("扩容后大小[Thread-0]:" + map.size()); } .start(); new Thread() { @Override public void run() { //放第13个元素，发生扩容 map.put(50,null); System.out.println("扩容后大小[Thread-1]:" + map.size()); } .start(); } final static int hash(Object k) { int h = 0;
```

```txt
if (0 != h && k instanceof String) {
return sun.misc.Hashe32((String) k);
}
h ^= k.hashCode();
h ^= (h >>> 20) ^ (h >>> 12);
return h ^ (h >>> 7) ^ (h >>> 4);
}
```

# 死链复现

调试工具使用idea

在 HashMap 源码 590 行加断点

```javascript
int newCapacity = newTable.length;
```

断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来

```txt
newTable.length  $= = 32$  &&  
（Thread.currentThread()..getName().equals("Thread-0")||Thread.currentThread()..getName().equals("Thread-1")）
```

断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行

运行代码，程序在预料的断点位置停了下来，输出

```txt
长度为16时，桶下标为1的key  
1  
16  
35  
50  
长度为32时，桶下标为1的key  
1  
35  
扩容前大小[main]:12
```

接下来进入扩容流程调试

在 HashMap 源码 594 行加断点

```txt
Entry  $\langle K,V\rangle$  next  $=$  e.next; // 593 if (rehash) // 594 // ...
```

这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件 Thread.currentThread()
..getName().equals("Thread-0")）

这时可以在 Variables 面板观察到 e 和 next 变量，使用 view as -> Object 查看节点状态

```txt
e (1)->(35)-(16)->null next (35)-(16)->null
```

在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成

```txt
newTable[1] (35) -> (1) -> null
```

扩容后大小：13

这时 Thread-0 还停在 594 处，Variables 面板变量的状态已经变化为

```html
e (1)->null next (35)-(1)->null
```

为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结果正确，但它结束后
Thread-0 还要继续运行

接下来就可以单步调试（F8）观察死链的产生了

下一轮循环到594，将e搬迁到newTable链表头

```txt
newTable[1] (1)->null e (35)-(1)->null next (1)->null
```

下一轮循环到 594，将 e 搬迁到ESHTable 链表头

```txt
newTable[1] (35)->(1)->null e (1)->null next null
```

再看看源码

```javascript
e.next  $=$  newTable[1];   
//这时e（1,35）   
//而newTable[1]  $(35,1)\rightarrow (1,35)$  因为是同一个对象   
newTable[1]  $=$  e;   
//再尝试将e作为链表头，死链已成   
e  $=$  next;   
//虽然next是null，会进入下一个链表的复制，但死链已经形成了
```

# 源码分析

HashMap 的并发死链发生在扩容时

```txt
// 将 table 迁移至 newVal
```

假设 map 中初始元素是

```txt
void transfer Entry[]newTable，boolean rehash）{ int newCapacity  $=$  newTable.length; for（Entry<K,V>e：table）{ while(null！  $\equiv$  e）{ Entry<K,V> next  $=$  e.next; //1处 if（rehash）{ e HASH  $=$  null  $= =$  e.key?0：hash(e.key); } int i  $=$  indexFor(e HASH，newCapacity); //2处 //将新元素加入newTable[i]，原newTable[i]作为新元素的next e.next  $=$  newTable[i]; newTable[i]  $=$  e; e  $=$  next; 1   
}
```

原始链表，格式：[下标] (key,next)

[1] (1,35) -> (35,16) -> (16,null)

线程a执行到1处，此时局部变量e为（1,35），而局部变量next为（35,16）线程a挂起

线程b开始执行

第一次循环

[1] (1,null)

第二次循环

[1] (35,1) ->(1,null)

第三次循环

[1] (35,1) ->(1,null)

[17] (16,null)

切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为（1,null），而 next 的内容被改为（35,1）并链向（1,null）

第一次循环

[1] (1,null)

第二次循环，注意这时 e 是（35,1）并链向（1,null）所以 next 又是（1,null）

[1] (35,1) ->(1,null)

第三次循环，e是（1,null），而next是null，但e被放入链表头，这样e.next变成了35（2处）

[1] (1,35)->(35,1)->(1,35)

已经是死链了

# 小结

- 究其原因，是因为在多线程环境下使用了非线程安全的 map 集合
- JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）

# 2. JDK 8 ConcurrentHashMap

# 重要属性和内部类

//默认为0

// 当初始化时，为 -1

// 当扩容时，为  $-(1 +$  扩容线程数)

// 当初始化或扩容完成后，为下一次的扩容的阈值大小

private transient volatile int sizeCtrl;

// 整个 ConcurrentHashMap 就是一个 Node[]

static class Node<K, V> implements Map.Entry<K, V> {}

//hash表

transient volatile Node<K,V>[ ] table;

//扩容时的新hash表

private transient volatile Node<K, V>[ ] nextTable;

// 扩容时如果某个 bin 迁移完毕，用 ForwardingNode 作为旧 table bin 的头结点

static final class ForwardingNode<K, V> extends Node<K, V> {}

// 用在 compute 以及 computeIfAbsent 时，用来占位，计算完成后替换为普通 Node

static final class ReservationNode<K, V> extends Node<K, V} {}

// 作为 treebin 的头节点，存储 root 和 first

static final class TreeBin<K, V> extends Node<K, V> {}

// 作为 treebin 的节点，存储 parent, left, right

static final class TreeNode<K, V> extends Node<K, V> {}

# 重要方法

// 获取 Node[] 中第 i 个 Node

static final  $<  \mathrm{K},\mathrm{V}>$  Node  $<  \mathrm{K},\mathrm{V}>$  tabAt(
Node  $<  \mathrm{K},\mathrm{V}>$  [] tab, int i)

// cas 修改 Node[] 中第 i 个 Node 的值，c 为旧值，v 为新值

static final  $<  \mathrm{K},\mathrm{V}>$  booleancasTabAt(Node  $<  \mathrm{K},\mathrm{V}>$  []
tab,inti,Node  $<  \mathrm{K},\mathrm{V}>$  c,Node  $<  \mathrm{K},\mathrm{V}>$  v)

// 直接修改 Node[] 中第 i 个 Node 的值，v 为新值

static final  $<  \mathrm{K},\mathrm{V}>$  void setTabAt(Node  $<  \mathrm{K},\mathrm{V}>$  [] tab, int i,
Node  $<  \mathrm{K},\mathrm{V}>$  v)

# 构造器分析

可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建

```txt
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
    if (!loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (initialCapacity < concurrencyLevel) // Use at least as many bins
        initialCapacity = concurrencyLevel; // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    // tableSizeFor仍然是保证计算的大小是2^n，即16,32,64...
    int cap = (size >= (long)MAXIMUM_CAPACITY)? MAXIMUM_CAPACITY : tableSizeFor((int)size);
    this.sizeCtl = cap;
}
```

# get流程

```txt
public V get(Object key) { Node<K, V>[ ] tab; Node<K, V> e, p; int n, eh; K ek; // spread 方法能确保返回结果是正数  
int h = spread(key.hashCode());  
if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(table, (n - 1) & h)) != null) { // 如果头结点已经是要查找的 key  
if ((eh = e hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) return e.val; }  
// hash 为负数表示该 bin 在扩容中或是 treebin，这时调用 find 方法来查找  
else if (eh < 0) return (p = e.find(h, key)) != null ? p.val : null; // 正常遍历链表，用 equals 比较  
while ((e = e.next) != null) { if (e hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; }  
}  
return null;
```

# put流程

以下数组简称（table），链表简称（bin）

```txt
public V put(K key, V value) {
```

```txt
return putchar(key, value, false);   
}   
final V putchar(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // 其中 spread 方法会综合高位低位，具有更好的 hash 性 int hash = spread(key.hashCode()); int binCount = 0; for (Node<K, V>[ ] tab = table;); // f 是链表头节点 // fh 是链表头结点的 hash // i 是链表在 table 中的下标 Node<K, V> f; int n, i, fh; // 要创建 table if (tab == null || (n = tab.length) == 0) // 初始化 table 使用了 cas，无需 synchronized 创建成功，进入下一轮循环 tab = initTable(); // 要创建链表头节点 else if ((f = tabAt_tab, i = (n - 1) & hash)) == null) { // 添加链表头使用了 cas，无需 synchronized if (casTabAt_tab, i, null, new Node<K, V>(hash, key, value, null)) break; } // 帮忙扩容 else if ((fh = fhash) == MOVED) // 帮忙之后，进入下一轮循环 tab = helpTransfer_tab, f); else { V oldVal = null; // 锁住链表头节点 synchronized (f) { // 再次确认链表头节点没有被移动 if (tabAtTAB, i) == f) { // 链表 if (fh >= 0) { binCount = 1; // 遍历链表 for (Node<K, V> e = f; ++binCount) { K ek; // 找到相同的 key if (e Hash == hash && ((ek = e.key) == key || (ek != null && key.equals ek)))) { oldVal = e.val; // 更新 if (!onlyIfAbsent) e.val = value; break; } Node<K, V> pred = e; // 已经是最后的节点了，新增 Node，追加至链表尾 if ((e = e.next) == null) {
```

```txt
pred.next  $=$  new Node<K,V>(hash,key, value,null); break; } } } //红黑树 else if (f instanceof TreeBin){ Node<K,V> p; binCount  $= 2$  . //putTreeVal会看key是否已经在树中，是，则返回对应的TreeNode if((p  $=$  ((TreeBin<K,V>)f).putTreeValHash,key, value)) != null）{ oldVal  $=$  p.val; if(!onlyIfAbsent) p.val  $=$  value; } } //释放链表头节点的锁 } if (binCount  $! = 0$  ）{ if (binCount >= TREEIFY_threshold) //如果链表长度  $\rightharpoondown$  树化阈值(8)，进行链表转为红黑树 treeifyBin(table,i); if(oldVal  $! =$  null) return oldVal; break; } } } //增加size计数 addCount(1L，binCount); return null; } private final Node<K,V>[ ] initTable() { Node<K,V>[ ] tab; int sc; while((tab  $=$  table)  $= =$  null || tab.length  $= = 0$  ）{ if((sc  $=$  sizeCtl)<0) Thread.yield(); //尝试将sizeCtl设置为-1（表示初始化table） else if(U compareAndSwapInt(this,SIZECTL,sc,-1)) { //获得锁，创建table，这时其它线程会在while()循环中yield直至table创建 try{ if((tab  $=$  table)  $= =$  null || tab.length  $= = 0$  ）{ int n  $=$  (sc>0)?sc:DEFAULT_CAPACITY; Node<K,V>[ ] nt  $=$  (Node<K,V>[ ])new Node<?>,?[n]; table  $=$  tab  $=$  nt; sc  $=$  n-(n>>2); } finally{
```

```lisp
sizeCt1  $=$  sc;   
} break;   
} return tab;   
}   
// check是之前 binCount的个数   
private final void addCount(long x,int check){ CounterCell[] as; long b,s; if( //已经有了counterCells，向cell累加 (as  $=$  counterCells）  $! =$  null || //还没有，向baseCount累加 !U compareAndSwapLong(this,BASECOUNT,b  $=$  baseCount,s  $= \mathrm{b} + \mathrm{x}$  ） { CounterCell a;long v;int m; boolean uncontended  $=$  true; if（ //还没有counterCells as  $= =$  null||  $(\mathfrak{m} =$  as.length-1）<0|| //还没有cell (a  $=$  as[ThreadLocalRandom.getProbe()&m]  $\equiv =$  null || //cellcas增加计数失败！(uncontended  $=$  U compareAndSwapLong(a,CELLVALUE,v=a.value,v+x)) } //创建累加单元数组和cell，累加重试 fullAddCount(x,uncontended); return; } if(check<=1) return; //获取元素个数 s  $=$  sumCount();   
} if(check  $> = 0$  { Node<K,V>[ ] tab,nt; int n,sc; while(s >= (long)(sc  $=$  sizeCt1)&& (tab  $=$  table)!  $=$  null && (n  $=$  tab.length)<MAXIMUM_CAPACITY}{ int rs  $=$  resizeStamp(n); if  $(\mathrm{sc}<  0)$  { if((sc>>RESIZE_STAMP_SHIFT)  $! =$  rs||sc==rs+1| | sc  $= =$  rs+MAX_RESIZERS||(nt  $=$  nextTable)  $\equiv =$  null || transferIndex  $\Leftarrow$  0) break; //newtable已经创建了，帮忙扩容 if(U compareAndSwapInt(this,SIZECTL,sc,sc+1)) transfer(table,nt); } //需要扩容，这时newtable未创建 elseif(U compareAndSwapInt(this,SIZECTL,sc, (rs<<RESIZE_STAMP_SHIFT)+2))
```

```txt
transfer_tab, null);
s = sumCount();
}
```

# size 计算流程

size 计算实际发生在 put, remove 改变集合元素的操作之中

- 没有竞争发生，向 baseCount 累加计数
- 有竞争发生，新建 counterCells，向其中的一个 cell 累加计数

○ counterCells 初始有两个 cell  
如果计数竞争比较激烈，会创建新的 cell 来累加计数

```txt
public int size(){ long n = sumCount(); return((n<0L)?0:(n>(long)Integer.MAX_VALUE)?Integer.MAX_VALUE : (int)n);   
}   
final long sumCount(){ CounterCell[] as  $=$  counterCells; CounterCell a; //将baseCount计数与所有cell计数累加 long sum  $=$  baseCount; if(as！  $= \mathrm{null}$  ）{ for(inti  $= 0$  ;i<as.length；++i）{ if((a  $=$  as[i])！  $=$  null) sum  $+ =$  a.value; } } return sum;
```

Java 8 数组 (Node) + (链表 Node | 红黑树TreeNode) 以下数组简称 (table), 链表简称 (bin)

- 初始化，使用cas来保证并发安全，懒惰初始化table
- 树化，当 table.length < 64 时，先尝试扩容，超过 64 时，并且 bin.length > 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头
- put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部
- get，无锁操作仅需要保证可见性，扩容过程中get操作拿到的是ForwardingNode它会让get操作在新table进行搜索
- 扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin
  进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中
- size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可

源码分析 http://www.Importnew.com/28263.html

其它实现 Clift Click's high scale lib

# 3. JDK 7 ConcurrentHashMap

它维护了一个segment数组，每个segment对应一把锁

- 优点：如果多个线程访问不同的segment，实际是没有冲突的，这与jdk8中是类似的
- 缺点：Segments 数组默认大小为 16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化

# 构造器分析

```txt
public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
    if (! (loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // ssize 必须是 2^n，即 2, 4, 8, 16 ... 表示了 segments 数组的大小
    int sshift = 0;
    int ssize = 1;
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <= 1;
    }
    // segmentShift 默认是 32 - 4 = 28
    thissegmentshift = 32 - sshift;
    // segmentMask 默认是 15 即 0000 0000 0000 1111
    thissegmentshift = ssize - 1;
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap < c)
        cap <= 1;
    // 创建 segments and segments[0]
    Segment<K,V> s0 =
        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
            (HashEntry<K,V>[ ])new HashEntry[cap]);
    Segment<K,V>[ ] ss = (Segment<K,V>[ ]) new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    thissegments = ss;
}
```

构造完成，如下图所示

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751525.jpg)  
Segments 数组

可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好

其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment 例如，根据某一 hash 值求
segment 位置，先将高位向低位移动 this.segmentShift 位

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751526.jpg)

结果再与 this.segmentMask 做位于运算，最终得到 1010 即下标为 10 的 segment

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751527.jpg)

put流程

```txt
public V put(K key, V value) {
    Segment<K, V> s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // 计算出 segment 下标
    int j = (hash >>> segmentShift) & segmentMask;
    // 获得 segment 对象，判断是否为 null，是则创建该 segment
    if ((s = (Segment<K, V>)UNSAFE的对象
        (segments, (j << SSHIFT) + SBASE)) == null) {
        // 这时不能确定是否真的为 null，因为其它线程也发现该 segment 为 null,
        // 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性
        s = ensureSegment(j);
    }
    // 进入 segment 的put 流程
    return s.put(key, hash, value, false);
}
```

segment 继承了可重入锁（ReentrantLock），它的 put 方法为

```txt
final V put(K key, int hash, V value, boolean onlyIfAbsent) {
// 尝试加锁
HashMap<K, V> node = tryLock() ? null :
// 如果不成功，进入 scanAndLockForPut 流程
// 如果是多核 cpu 最多 tryLock 64 次，进入 lock 流程
// 在尝试期间，还可以顺便看该节点在链表中有没有，如果没有顺便创建出来
scanAndLockForPut(key, hash, value);
// 执行到这里 segment 已经被成功加锁，可以安全执行
V oldValue;
try {
HashMap<K, V>[ ] tab = table;
int index = (tab.length - 1) & hash;
HashMap<K, V> first = entryAt_tab, index);
for (HashMap<K, V> e = first;;) {
if (e != null) {
// 更新
K k;
if ((k = e.key) == key ||
(e.hashCode == hash && key.equals(k)))) {
oldValue = e.value;
if (!onlyIfAbsent) {
e.value = value;
++modCount;
}
```

```javascript
break;   
} e  $=$  e.next;   
} else{ //新增 //1）之前等待锁时，node已经被创建，next指向链表头 if(node  $! =$  null) node.setNext(first); else //2）创建新node node  $=$  new HashEntry<K,V>(hash,key, value,first); intc  $=$  count+1; //3）扩容 if(c  $>$  threshold&&tab.length  $<$  MAXIMUM_CAPACITY) rehash(node); else //将node作为链表头 setEntryAt(table,index,node); ++modCount; count  $=$  c; oldValue  $=$  null; break; } } }finally{ unlock(); } return oldValue;
```

# rehash流程

发生在put中，因为此时已经获得了锁，因此rehash时不需要考虑线程安全

```java
private void rehash(HashEntry<K, V> node) {
    HashEntry<K, V>[ ] oldTable = table;
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity << 1;
    threshold = (int)(newCapacity * loadFactor);
    HashEntry<K, V>[ ] newTable = (HashEntry<K, V>[ ]) new HashEntry[新规Capacity];
    int sizeMask =新规Capacity - 1;
    for (int i = 0; i <新规Capacity; i++) {
        HashEntry<K, V> e = oldTable[i];
        if (e != null) {
            HashEntry<K, V> next = e.next;
            int idx = e.size & sizeMask;
            if (next == null) // Single node on list
                newTable[idx] = e;
            else { // Reuse consecutive sequence at same slot
                HashEntry<K, V> lastRun = e;
            }
        }
    }
}
```

附，调试代码

```javascript
intlastIdx  $=$  idx; //过一遍链表，尽可能把rehash后idx不变的节点重用 for(HashEntry<K,V>last  $\equiv$  next; last  $! =$  null; last  $=$  last.next）{ intk  $=$  last.hash& sizeMask; if（k！  $=$  lastIdx）{ lastIdx  $\equiv$  k; lastRun  $\equiv$  last; } }newTable[last]  $\equiv$  lastRun; //剩余节点需要新建 for(HashEntry<K,V>  $\mathfrak{p} = \mathfrak{e};\mathfrak{p}$  ！  $= 1$  lastRun；  $\mathfrak{p} = \mathfrak{p}$  .next）{ Vv  $=$  p.value; inth  $=$  p.hash; intk=h&sizeMask; HashEntry<K,V> n  $=$  newNode[k]; newNode[k]  $\equiv$  new HashEntry<K,V>(h,p.key,v,n); } } } //扩容完成，才加入新的节点 intnodeIndex  $\equiv$  node.hash& sizeMask; //add the new node node.setNext(newTable[nodeIndex]); newNode[nodeIndex]  $\equiv$  node; //替换为新的HashEntry table table  $\equiv$  newNode;
```

```java
public static void main(String[] args) { ConcurrentHashMap<String> map = new ConcurrentHashMap<>(); for (int i = 0; i < 1000; i++) { int hash = hash(i); int segmentIndex = (hash >> 28) & 15; if (segmentIndex == 4 && hash % 8 == 2) { System.out.println(i + "\t" + segmentIndex + "\t" + hash % 2 + "\t" + hash % 4 + "\t" + hash % 8); } map.put(1, "value"); map.put(15, "value"); // 2 扩容为 4 15 的 hash%8 与其他不同 map.put(169, "value"); map.put(197, "value"); // 4 扩容为 8 map.put(341, "value"); map.put(484, "value"); map.put(545, "value"); // 8 扩容为 16 map.put(912, "value");
```

```java
map.put(941, "value"); System.out.println("ok");   
}   
private static int hash(Object k) { int h = 0; if ((0 != h) && (k instanceof String)) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h << 15) ^ 0xFFFFFFcd7d; h ^= (h >>> 10); h += (h << 3); h ^= (h >>> 6); h += (h << 2) + (h << 14); int v = h ^ (h >>> 16); return v;
```

# get流程

get时并未加锁，用了UNSAFE方法保证了可见性，扩容过程中，get先发生就从旧表取内容，get后发生就从新表取内容

```java
public V get(Object key) { Segment<K, V> s; // manually integrate access methods to reduce overhead HashEntry<K, V>[ ] tab; int h = hash(key); // u为segment对象在数组中的偏移量 long u = (((h >> segmentShift) & segmentMask) << SSHIFT) + SBASE; //s即为segment if ((s = (Segment<K, V>)UNSAFE的对象在数组中的偏移量 (tab = s.table) != null) { for (HashEntry<K, V> e = (HashEntry<K, V>) UNSAFE的对象在数组中的偏移量 (tab, ((long)((tab.length - 1) & h)) << TSHIFT) + TBASE); e != null; e = e.next) { K k; if ((k = e.key) == key || (ehash == h && key.equals(k))) return e.value; } } return null; }
```

# size 计算流程

- 计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回
- 如果不一样，进行重试，重试次数超过3，将所有segment锁住，重新计算个数返回

```txt
public int size() { // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment<K,V>[ ] segments = thissegments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try { for (;;) { if (retries++) == RETRIES_BEFORE_LOCK) { // 超过重试次数，需要创建所有 segment 并加锁 for (int j = 0; j < segments.length; ++j) ensureSegment(j).lock(); // force creation } sum = 0L; size = 0; overflow = false; for (int j = 0; j < segments.length; ++j) { Segment<K,V> seg = segmentAt(segments, j); if (seg != null) { sum += seg.modCount; int c = seg.count; if (c < 0 || (size <= c) < 0) overflow = true; } } if (sum == last) break; last = sum; } } finally { if (retries > RETRIES_BEFORE_LOCK) { for (int j = 0; j < segments.length; ++j) segmentAt(segments, j).unlock(); } } return overflow ? Integer.MAX_VALUE : size; }
```

# LinkedBlockingQueue 原理

# 1. 基本的入队出队

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, java.io.Serializable { static class Node<E> {
```

```javascript
E item; /\*\* \*下列三种情况之一 \* -真正的后继节点 \* -自己，发生在出队时 \* -null，表示是没有后继节点，是最后了 \*/ Node<Ev>next; Node(Ex){item=x;} 1
```

初始化链表last = head = new Node<E>(null); Dummy节点用来占位，item为null

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751528.jpg)

当一个节点入队 last = last.next = node;

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751529.jpg)

再来一个节点入队 last = last.next = node;

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751530.jpg)

出队

```txt
Node  $\langle E\rangle$  h = head;   
Node  $\langle E\rangle$  first  $=$  h.next;   
h.next  $=$  h; // help GC   
head  $=$  first;   
E x  $=$  first.item;   
first.item  $=$  null;   
return x;
```

```txt
h = head
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751531.jpg)

```txt
first = h.next
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751532.jpg)

```txt
h.next = h
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751533.jpg)

```txt
head = first
```

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751534.jpg)

E x = first.item;

first.item = null;

return x;

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154751535.jpg)

# 2. 加锁分析

$= =$  高明之处  $= =$  在于用了两把锁和dummy节点

- 用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行
- 用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行

消费者与消费者线程仍然串行  
○ 生产者与生产者线程仍然串行

# 线程安全分析

- 当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head
  节点的线程安全。两把锁保证了入队和出队没有竞争
- 当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争
- 当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞

// 用于 put(阻塞) offer(非阻塞)

private final ReentrantLock putLock = new ReentrantLock();

// 用户 take(阻塞) poll(非阻塞)

private final ReentrantLock takeLock = new ReentrantLock();

put操作

public void put(E e) throws InterruptedException {

take操作

```txt
if (e == null) throw new EmptySignal() 而不是 notEmpty.signalAll() 是为了减少竞争 signalNotEmpty();
```

```java
public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        while (count.get() == 0) {
            notEmptyawait();
        }
        x = dequeue();
        c = count.getAndDecrement();
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
} // 如果队列中只有一个空位时，叫醒 put 线程
// 如果有多个线程进行出队，第一个线程满足 c == capacity，但后续线程 c < capacity
if (c == capacity) // 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争
signalNotFull()
```

```lisp
return x; }
```

由put唤醒put是为了避免信号不足

# 3. 性能比较

主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较

- Linked 支持有界，Array 强制有界
- Linked 实现是链表，Array 实现是数组
- Linked 是懒惰的，而 Array 需要提前初始化 Node 数组
- Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的
- Linked 两把锁，Array —— 把锁

# ConcurrentLinkedQueue 原理

# 1. 模仿 ConcurrentLinkedQueue

初始代码

```java
package cn.itcast.concurrent.thirdpart.test;   
import java.utilCollection;   
import java.util Iterator;   
import java.util. Queue;   
import java.util.concurrent.atomicyncatomicAtomicReference;   
public class Test3 { public static void main(String[] args) { MyQueue<String> queue  $=$  new MyQueue<>(); queue Offer("1"); queue offer("2"); queue offer("3"); System.out.println.queue); }
```

```java
class MyQueue<E>implements Queue<E> {
    @Override
    public String toString() {
       StringBuilder sb = new StringBuilder();
        for (Node<E> p = head; p != null; p = p.next.get())
            E item = p.item;
            if (item != null) {
                sb.append(item).append("");
```

```java
return false;   
}   
@override   
public boolean containsAll(Collection<?> c) { return false;   
}   
@override   
public boolean addAll(Collection<? extends E> c) { return false;   
}   
@override   
public boolean removeAll(Collection<?> c) { return false;   
}   
@override   
public boolean retainAll(Collection<?> c) { return false;   
}   
@override   
public void clear() {   
}   
@override   
public E remove() { return null;   
}   
@override   
public E element() { return null;   
}   
@override   
public E peek() { return null;   
}   
public MyQueue() { head = last = new Node<(null, null);   
}   
private volatile Node<E> last;   
private volatile Node<E> head;   
private E deque() {
```

offer

```txt
/*Node  $\varepsilon >$  h  $=$  head; Node  $\varepsilon >$  first  $=$  h.next; h.next  $=$  h; head  $=$  first; E x  $=$  first.item; first.item  $=$  null; return x;*/ return null;   
}   
@override public E poll() { return null;   
}   
@override public boolean offer(E e){ return true;   
}   
static class NodeE{ volatile E item; public Node(E item, Node  $\varepsilon >$  next）{ this.item  $=$  item; this.next  $=$  newAtomicReference  $\varepsilon >$  (next); } AtomicReference<Node  $\varepsilon >$  next;   
}
```

```txt
public boolean offer(E e) { Node<E> n = new Node<(e, null); while(true) { // 获取尾节点 AtomicReference<Node<E>> next = last.next; // S1: 真正尾节点的 next 是 null, cas 从 null 到新节点 if(next compareAndSet(null, n)) { // 这时的 last 已经是倒数第二，next 不为空了，其它线程的 cas 肯定失败 // S2: 更新 last 为倒数第一的节点 last = n; return true; } }
```