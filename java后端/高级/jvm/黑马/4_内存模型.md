# 1. java 内存模型

很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。

```txt
关于它的权威解释，请参考 https://download.Oracle.com/otn-pub/jcp/memory_model-1.0-pfd-spec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?  
AuthParam=1562811549 4d4994cbd5b59d964cd2907ea22ca08b
```

简单的说，JMM定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障

# 1.1 原子性

原子性在学习线程时讲过，下面来个例子简单回顾一下：

问题提出，两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0吗？

# 1.2 问题分析

以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。

例如对于  $i++$  而言 (i 为静态变量), 实际会产生如下的 JVM 字节码指令:

```txt
getstatic i // 获取静态变量i的值  
iconst_1 // 准备常量1  
iadd // 加法  
putstatic i // 将修改后的值存入静态变量i
```

而对应 i-- 也是类似：

```txt
getstatic i // 获取静态变量i的值  
iconst_1 // 准备常量1  
isub // 减法  
putstatic i // 将修改后的值存入静态变量i
```

而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：

# 主内存 static int i = 0

# 线程1i++

# 线程2i--

如果是单线程以上8行代码是顺序执行（不会交错）没有问题：

// 假设i的初始值为0

```txt
getstatic i //线程1-获取静态变量i的值线程内i=0  
const_1 //线程1-准备常量1  
iadd //线程1-自增线程内i=1  
putstatic i //线程1-将修改后的值存入静态变量i 静态变量i=1  
getstatic i //线程1-获取静态变量i的值线程内i=1  
const_1 //线程1-准备常量1  
isub //线程1-自减线程内i=0  
putstatic i //线程1-将修改后的值存入静态变量i 静态变量i=0
```

但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）：

出现负数的情况：

// 假设i的初始值为0

```txt
getstatic i //线程1-获取静态变量i的值 线程内i=0  
getstatic i //线程2-获取静态变量i的值 线程内i=0  
const_1 //线程1-准备常量1  
iadd //线程1-自增 线程内i=1  
putstatic i //线程1-将修改后的值存入静态变量i 静态变量i=1  
const_1 //线程2-准备常量1  
isub //线程2-自减 线程内i=-1  
putstatic i //线程2-将修改后的值存入静态变量i 静态变量i=-1
```

出现正数的情况：

// 假设i的初始值为0

```shell
getstatic i //线程1-获取静态变量i的值 线程内i=0  
getstatic i //线程2-获取静态变量i的值 线程内i=0  
const_1 //线程1-准备常量1  
iadd //线程1-自增 线程内i=1  
const_1 //线程2-准备常量1  
isub //线程2-自减 线程内i=-1  
putstatic i //线程2-将修改后的值存入静态变量i 静态变量i=-1  
putstatic i //线程1-将修改后的值存入静态变量i 静态变量i=1
```

# 1.3 解决方法

synchronized (同步关键字)

语法

```txt
synchronized（对象）{要作为原子操作代码}
```

用 synchronized 解决并发问题：

```java
static int i = 0;   
static object obj = new object();   
public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread() -> { for (int j = 0; j < 5000; j++) { synchronized (obj) { i++; } } };   
Thread t2 = new Thread() -> { for (int j = 0; j < 5000; j++) { synchronized (obj) { i--; } } };   
t1.start();   
t2.start();   
t1.join();   
t2.join();   
system.out.println(i);
```

如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。

当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行 count++ 代码。

这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。

当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的
count-- 代码。

注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2
对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。

# 2. 可见性

# 2.1 退不出的循环

先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：

```txt
static boolean run = true;   
public static void main(String[] args) throws InterruptedException { Thread t  $=$  new Thread(  $)\rightarrow$  { while(run){ //.... } ）； t.start(); Thread.sleep(1000); run  $=$  false; //线程t不会如预想的停下来
```

为什么呢？分析一下：

1. 初始状态，t线程刚开始从主内存读取了run的值到工作内存。

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154529229.jpg)

2. 因为  $t$  线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run
   的访问，提高效率

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154529230.jpg)

3.1秒之后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值

![](https://cdn.jsdelivr.net/gh/mayuhaos/blog-images@main/pdf-ocr-images/20251129154529231.jpg)

# 2.2 解决方法

volatile (易变关键字)

它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作
volatile 变量都是直接操作主存

# 2.3 可见性

前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况：

上例从字节码理解是这样的：

```txt
getstatic run //线程t获取run true  
getstatic run //线程t获取run true  
getstatic run //线程t获取run true  
getstatic run //线程t获取run true  
putstatic run //线程main修改run为false，仅此一次  
getstatic run //线程t获取run false
```

比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i--，只能保证看到最新值，不能解决指令交错

// 假设i的初始值为0

```txt
getstatic i //线程1-获取静态变量i的值 线程内i=0  
getstatic i //线程2-获取静态变量i的值 线程内i=0  
const_1 //线程1-准备常量1  
iadd //线程1-自增 线程内i=1  
putstatic i //线程1-将修改后的值存入静态变量i 静态变量i=1  
const_1 //线程2-准备常量1  
isub //线程2-自减 线程内i=-1  
putstatic i //线程2-将修改后的值存入静态变量i 静态变量i=-1
```

# 注意

synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低

如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run
变量的修改了，想一想为什么？

# 3. 有序性

# 3.1 诡异的结果

```txt
int num = 0;  
boolean ready = false;  
// 线程1执行此方法  
public void actor1(I(Result r) {  
    if (ready) {  
        r.r1 = num + num;  
    } else {  
        r.r1 = 1;  
    }  
}  
// 线程2执行此方法  
public void actor2(I(Result r) {  
    num = 2;  
    ready = true;  
}
```

I(Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？

有同学这么分析

情况1：线程1先执行，这时ready = false，所以进入else分支结果为1  
情况2：线程2先执行num = 2，但没来得及执行ready = true，线程1执行，还是进入else分支，结果为1  
情况3：线程2执行到  $\mathrm{ready} = \mathrm{true}$ ，线程1执行，这回进入if分支，结果为4（因为num已经执行过了）

这种情况下是：线程2执行ready = true，切换到线程1，进入if分支，相加为0，再切回线程2执行num = 2

相信很多人已经晕了

这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：

借助java并发压测工具jcstresshttps://wiki.openjdk.java.net/display/CodeTools/jcstress

```batch
mvn archetype:generate -DinteractiveMode=false - DarchetypegroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test- archetype -DgroupId=org/sample -DartifactId=test -Dversion=1.0
```

创建maven项目，提供如下测试类

```txt
@JCStressTest   
@Outcome(id  $=$  {"1"，"4"}，expect  $=$  Expect.ACEPTABLE，desc  $=$  "ok")   
@Outcome(id  $=$  "0"，expect  $=$  Expect.ACEPTABLE_INTERESTING，desc  $=$  "！！！")   
@State   
public classConcurrencyTest{ int num  $= 0$  boolean ready  $=$  false; @Actor public void actor1(I(Result r){ ifready）{ r.r1  $\equiv$  num  $^+$  num; } else { r.r1  $= 1$  ； }   
}   
@Actor public void actor2(I(Result r){ num  $= 2$  ： ready  $\equiv$  true; }
```

# 执行

```batch
mvn clean install
java -jar target/jcstress.jar
```

会输出我们感兴趣的结果，摘录其中一次结果：

```txt
\*\*\* INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 2 matching test results. [OK] test.ConcurrencyTest (JVM args:[-XX:-TieredCompilation]) Observed state Occurrences Expectation Interpretation
```

```csv
0 1,729 ACCEPTABLE_INTERESTING !!!!  
1 42,617,915 ACCEPTABLE ok  
4 5,146,627 ACCEPTABLE ok  
[OK] test.ConcurrencyTest  
(JVM args:[])  
observed state Occurrences Expectation Interpretation  
0 1,652 ACCEPTABLE_INTERESTING !!!!  
1 46,460,657 ACCEPTABLE ok  
4 4,571,072 ACCEPTABLE ok
```

可以看到，出现结果为0的情况有638次，虽然次数相对很少，但毕竟是出现了。

# 3.2 解决方法

volatile 修饰的变量，可以禁用指令重排

```lisp
@JCStressTest   
@Outcome(id  $=$  {"1"，"4"}，expect  $=$  Expect.ACEPTABLE，desc  $=$  "ok")   
@Outcome(id  $=$  "0"，expect  $=$  Expect.ACEPTABLE_INTERESTING，desc  $=$  ""！！！！")   
@State   
public classConcurrencyTest{ int num  $= 0$  volatilebooleanready  $\equiv$  false; @Actor public void actor1(I(Result r){ if(ready）{ r.r1  $\equiv$  num  $^+$  num; }else{ r.r1  $= 1$  ； }   
}   
@Actor public void actor2(I(Result r){ num  $= 2$  ready  $\equiv$  true; }
```

结果为：

```txt
\*\*\* INTERESTING tests Some interesting behaviors observed. This is for the plain curiosity. 0 matching test results.
```

# 3.3 有序性理解

JVM会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码

```txt
static int i;   
static int j;   
//在某个线程内执行如下赋值操作  $\mathrm{i} = \dots ; / /$  较为耗时的操作   
 $\mathrm{j} = \dots$
```

可以看到，至于是先执行i还是先执行j，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是

```latex
$\mathrm{i} = \dots ; / /$  较为耗时的操作  
 $\mathrm{j} = \dots ;$
```

也可以是

```txt
j  $= \dots$  ·  
i  $= \dots$  ； // 较为耗时的操作
```

这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性，例如著名的 double-checked locking 模式实现单例

```java
public final class Singleton {
    private Singleton() {}
    private static SingletonINSTANCE = null;
    public static Singleton.getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) {
                    instances = new Singleton();
                }
            }
        }
    returnINSTANCE;
}
```

以上的实现特点是：

- 懒惰实例化
- 首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁

但在多线程环境下，上面的代码是有问题的，INSTANCE = new Singleton() 对应的字节码为：

```txt
0: new #2 // class cn/itcast/jvm/t4/Singleton  
3: dup  
4: invokespecial #3 // Method "<init>":()V  
7: putstatic #4 // Field  
INSTANCE:Lcn/itcast/jvm/t4/Singleton;
```

其中47两步的顺序不是固定的，也许jvm会优化为：先将引用地址赋值给INSTANCE变量后，再执行构造方法，如果两个线程t1，t2按如下时间序列执行：

```txt
时间1 t1 线程执行到INSTANCE = new singleton();  
时间2 t1 线程分配空间，为singleton对象生成了引用地址（0处）  
时间3 t1 线程将引用地址赋值给INSTANCE，这时INSTANCE != null（7处）  
时间4 t2 线程进入getInstance()方法，发现INSTANCE != null（synchronized块外），直接返回INSTANCE  
时间5 t1 线程执行singleton的构造方法（4处）
```

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例

对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意在JDK5以上的版本的volatile才会真正有效

# 3.4 happens-before

happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM
并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见

- 线程解锁  $m$  之前对变量的写, 对于接下来对  $m$  加锁的其它线程对该变量的读可见

```txt
static int x;   
static object m = new Object();   
new Thread(）->{ synchronized(m){  $\texttt{x} = 10$  1   
},"t1").start();   
new Thread(）->{ synchronized(m）{ System.out.println(x); }   
}, "t2").start();
```

- 线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

```txt
volatile static int x;   
new Thread()->{  $\mathbf{x} = 10$  . }，"t1").start();   
new Thread()->{ System.out.println(x); }，"t2").start();
```

- 线程 start 前对变量的写，对该线程开始后对该变量的读可见

```javascript
static int x;   
 $\mathbf{x} = \mathbf{10}$    
new Thread(）->{ System.out.println(x); }，"t2").start();
```

- 线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）

```javascript
static int x;   
Thread t1  $=$  new Thread(  $)\rightarrow$  {  $\mathbf{x} = 10$  . }，"t1");   
t1.start();   
t1.join();   
System.out.println(x);
```

- 线程 t1 打断 t2 (interrupt) 前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或
  t2.isInterrupted）

```java
static int x;   
public static void main(String[] args) { Thread t2  $=$  new Thread(  $)\rightarrow$  { while(true){ if(Thread.currentThread().isInterrupted()）{ System.out.println(x); break; } } },"t2"); t2.start();   
new Thread(  $)\rightarrow$  { try{ Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }  $\mathbf{x} = 10$  . t2.interrupt(); }, "t1").start();   
while(!t2.isInterrupted()){ Thread.yield(); } System.out.println(x);
```

- 对变量默认值（0，false，null）的写，对其它线程对该变量的读可见
- 具有传递性，如果  $x \mathrm{~hb} \rightarrow y$  并且  $y \mathrm{~hb} \rightarrow z$
  那么有  $x \mathrm{~hb} \rightarrow z$

变量都是指成员变量或静态成员变量

参考：第17页

# 4. CAS与原子类

# 4.1 CAS

CAS即Compare and Swap，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行+1操作：

```javascript
// 需要不断尝试  
while(true) {  
    int 旧值 = 共享变量; // 比如拿到了当前值 0  
    int 结果 = 旧值 + 1; // 在旧值 0 的基础上增加 1，正确结果是 1  
    /*  
        这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候 compareAndSwap 返回 false，重新尝试，直到： compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰 */  
        if (compareAndSwap(旧值，结果)) {  
            // 成功，退出循环  
        }  
}
```

获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核
CPU 的场景下。

- 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一  
  但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响

CAS底层依赖于一个Unsafe类来直接调用操作系统底层的CAS指令，下面是直接使用Unsafe对象进行线程安全保护的一个例子

```java
import sun.misc.Unsafe;   
import java.lang.reflect.Field;   
public class TestCAS { public static void main(String[] args) throws InterruptedException { DataContainer dc  $=$  new DataContainer(); int count  $= 5$
```

```txt
Thread t1 = new Thread() -> {
    for (int i = 0; i < count; i++) {
        dc.increase();
    }
});  
t1.start();
t1.join();
System.out.println(dc的数据());
}
```

```txt
public intGetData(){ return data; }   
1
```

# 4.2 乐观锁与悲观锁

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁，你们都别想改，我改完了解开锁，你们才有机会。

# 4.3 原子操作类

juc (java.util.concurrent) 中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，它们底层就是采用
CAS 技术 + volatile 来实现的。

可以使用 AtomicInteger 改写之前的例子：

```java
// 创建原子整数对象
private static AtomicInteger i = new AtomicInteger(0);
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread() -> {
        for (int j = 0; j < 5000; j++) {
            i.getAndIncrement(); // 获取并且自增 i++
        }
    }
}
```

```javascript
Thread t2 = new Thread() -> {
    for (int j = 0; j < 5000; j++) {
        i.getAndDecrement(); // 获取并且自减 i--
    }
});
```

# 5. synchronized 优化

Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word
平时存储这个对象的哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容

# 5.1轻量级锁

如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。这就好比：

学生（线程A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。

如果这期间有其它学生（线程B）来了，会告知（线程A）有并发访问，线程A随即升级为重量级锁，进入重量级锁的流程。

而重量级锁就不是那么用课本占座那么简单了，可以想象线程A走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁

```txt
static object obj = new object();  
public static void method1() {  
    synchronized (obj) {  
        // 同步块 A  
        method2();  
    }  
}  
public static void method2() {  
    synchronized (obj) {  
        // 同步块 B  
    }  
}
```

每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的MarkWord

<table><tr><td>线程1</td><td>对象Mark Word</td><td>线程2</td></tr><tr><td>访问同步块A,把Mark复制到线程1的锁记录</td><td>01(无锁)</td><td>-</td></tr><tr><td>CAS 修改Mark为线程1锁记录地址</td><td>01(无锁)</td><td>-</td></tr><tr><td>成功(加锁)</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>执行同步块A</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>访问同步块B,把Mark复制到线程1的锁记录</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>CAS 修改Mark为线程1锁记录地址</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>失败(发现是自己的锁)</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>锁重入</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>执行同步块B</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>同步块B执行完毕</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>同步块A执行完毕</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>成功(解锁)</td><td>01(无锁)</td><td>-</td></tr><tr><td>-</td><td>01(无锁)</td><td>访问同步块A,把Mark复制到线程2的锁记录</td></tr><tr><td>-</td><td>01(无锁)</td><td>CAS 修改Mark为线程2锁记录地址</td></tr><tr><td>-</td><td>00(轻量锁)线程2锁记录地址</td><td>成功(加锁)</td></tr><tr><td>-</td><td>...</td><td>...</td></tr></table>

# 5.2 锁膨胀

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。

```swift
static Object obj = new Object();  
public static void method1() {  
    synchronized (obj) {  
        // 同步块  
    }  
}
```

<table><tr><td>线程1</td><td>对象Mark</td><td>线程2</td></tr><tr><td>访问同步块,把Mark复制到线程1的锁记录</td><td>01(无锁)</td><td>-</td></tr><tr><td>CAS 修改Mark为线程1锁记录地址</td><td>01(无锁)</td><td>-</td></tr><tr><td>成功(加锁)</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程1锁记录地址</td><td>-</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程1锁记录地址</td><td>访问同步块,把Mark复制到线程2</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程1锁记录地址</td><td>CAS 修改Mark为线程2锁记录地址</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程1锁记录地址</td><td>失败(发现别人已经占了锁)</td></tr><tr><td>执行同步块</td><td>00(轻量锁)线程1锁记录地址</td><td>CAS 修改Mark为重量锁</td></tr><tr><td>执行同步块</td><td>10(重量锁)重量锁指针</td><td>阻塞中</td></tr><tr><td>执行完毕</td><td>10(重量锁)重量锁指针</td><td>阻塞中</td></tr><tr><td>失败(解锁)</td><td>10(重量锁)重量锁指针</td><td>阻塞中</td></tr><tr><td>释放重量锁,唤起阻塞线程竞争</td><td>01(无锁)</td><td>阻塞中</td></tr><tr><td>-</td><td>10(重量锁)</td><td>竞争重量锁</td></tr><tr><td>-</td><td>10(重量锁)</td><td>成功(加锁)</td></tr><tr><td>-</td><td>...</td><td>...</td></tr></table>

# 5.3重量锁

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

在Java 6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。

- 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。
- 好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）
- Java 7 之后不能控制是否开启自旋功能

自旋重试成功的情况

<table><tr><td>线程1 (cpu 1上)</td><td>对象Mark</td><td>线程2 (cpu 2上)</td></tr><tr><td>-</td><td>10 (重量锁)</td><td>-</td></tr><tr><td>访问同步块,获取monitor</td><td>10 (重量锁) 重量锁指针</td><td>-</td></tr><tr><td>成功 (加锁)</td><td>10 (重量锁) 重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>访问同步块,获取monitor</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>成功 (解锁)</td><td>01 (无锁)</td><td>自旋重试</td></tr><tr><td>-</td><td>10 (重量锁) 重量锁指针</td><td>成功 (加锁)</td></tr><tr><td>-</td><td>10 (重量锁) 重量锁指针</td><td>执行同步块</td></tr><tr><td>-</td><td>...</td><td>...</td></tr></table>

自旋重试失败的情况

<table><tr><td>线程1 (cpu 1上)</td><td>对象Mark</td><td>线程2 (cpu 2上)</td></tr><tr><td>-</td><td>10 (重量锁)</td><td>-</td></tr><tr><td>访问同步块,获取monitor</td><td>10 (重量锁) 重量锁指针</td><td>-</td></tr><tr><td>成功 (加锁)</td><td>10 (重量锁) 重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>访问同步块,获取monitor</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10 (重量锁) 重量锁指针</td><td>阻塞</td></tr><tr><td>-</td><td>...</td><td>...</td></tr></table>

# 5.4 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用
CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS.

- 撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）
- 访问对象的 hashCode 也会撤销偏向锁
- 如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的Thread ID
- 撤销偏向和重偏向都是批量进行的，以类为单位
- 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的
- 可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁

可以参考这篇论文：https://www.Oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf

假设有两个方法同步块，利用同一个对象加锁

```txt
static Object obj = new Object();  
public static void method1() {  
    synchronized (obj) {  
        // 同步块 A  
        method2();  
    }  
}  
public static void method2() {  
    synchronized (obj) {  
        // 同步块 B  
    }  
}
```

<table><tr><td>线程1</td><td>对象Mark</td></tr><tr><td>访问同步块A，检查Mark中是否有线程ID</td><td>101（无锁可偏向）</td></tr><tr><td>尝试加偏向锁</td><td>101（无锁可偏向）对象hashCode</td></tr><tr><td>成功</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块A</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>访问同步块B，检查Mark中是否有线程ID</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>是自己的线程ID，锁是自己的，无需做更多操作</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行同步块B</td><td>101（无锁可偏向）线程ID</td></tr><tr><td>执行完毕</td><td>101（无锁可偏向）对象hashCode</td></tr></table>

# 5.5 其它优化

# 1. 减少上锁时间

同步代码块中尽量短

# 2. 减少锁的粒度

将一个锁拆分为多个锁提高并发度，例如：

- ConcurrentHashMap
- LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到
  base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base
  就是最终的值
- LinkedBlockingQueue 入队和出队使用不同的锁，相对于 LinkedBlockingArray 只有一个锁效率要高

# 3. 锁粗化

多次循环进入同步块不如同步块内多次循环

另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）

```javascript
new StringBuffer().append("a").append("b").append("c");
```

# 4. 锁消除

JVM会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。

# 5. 读写分离

CopyOnWriteArrayList

ConyOnWriteSet

参考：

https://wiki.openjdk.java.net/display/HotSpot/Synchronization

http://luojinping.com/2015/07/09/java锁优化/

https://www.infoq.cn/article/java-se-16-synchronized

https://www.jianshu.com/p/9932047a89be

https://www.cnblogs.com/sheeva/p/6366782.html

https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock